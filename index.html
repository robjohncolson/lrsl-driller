<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSRL Conclusion Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.min.js"></script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; }
        .card-flip { transition: transform 0.6s; transform-style: preserve-3d; }
        .card-flip.flipped { transform: rotateX(180deg); }
        textarea:focus { outline: none; }
        .hint-text { display: none; }
        .hint-text.show { display: block; }
        .streak-pulse { animation: pulse 0.5s ease-in-out; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .feedback-card { transition: all 0.3s ease-out; }
        .katex-like { font-family: "Times New Roman", serif; font-style: italic; }

        /* Celebration effects */
        .screen-flash {
            animation: flash 0.5s ease-out;
        }
        @keyframes flash {
            0% { background-color: rgba(34, 197, 94, 0.3); }
            100% { background-color: transparent; }
        }
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            z-index: 100;
            pointer-events: none;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Sticky scenario card */
        .scenario-sticky {
            position: sticky;
            top: 60px;
            z-index: 30;
        }

        /* Button visibility fix */
        .btn-hidden { display: none !important; }
        .btn-visible { display: inline-flex !important; }

        /* Toast notification animation */
        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .animate-slide-in {
            animation: slide-in 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-md sticky top-0 z-40">
        <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <h1 class="text-xl font-bold text-purple-700">LSRL Conclusion Trainer</h1>
            </div>
            <div class="flex items-center gap-6">
                <!-- Streak Counters -->
                <div class="flex gap-4 text-sm">
                    <div class="flex items-center gap-2 relative group cursor-help">
                        <!-- Info icon -->
                        <span class="text-gray-400 text-xs">‚ìò</span>
                        <!-- Star counts -->
                        <span class="flex items-center gap-0.5" title="Gold: All correct, no hints">
                            <span class="text-yellow-400">‚òÖ</span>
                            <span id="gold-count" class="font-bold text-yellow-600 bg-yellow-100 px-1.5 py-0.5 rounded text-xs">0</span>
                        </span>
                        <span class="flex items-center gap-0.5" title="Silver: All correct, 1 hint">
                            <span class="text-gray-400">‚òÖ</span>
                            <span id="silver-count" class="font-bold text-gray-500 bg-gray-200 px-1.5 py-0.5 rounded text-xs">0</span>
                        </span>
                        <span class="flex items-center gap-0.5" title="Bronze: All correct, 2 hints">
                            <span class="text-amber-600">‚òÖ</span>
                            <span id="bronze-count" class="font-bold text-amber-700 bg-amber-100 px-1.5 py-0.5 rounded text-xs">0</span>
                        </span>
                        <span class="flex items-center gap-0.5" title="Tin: All correct, 3 hints">
                            <span class="text-stone-400">‚òÖ</span>
                            <span id="tin-count" class="font-bold text-stone-500 bg-stone-200 px-1.5 py-0.5 rounded text-xs">0</span>
                        </span>
                        <!-- Tier 2 Stars (hidden until unlocked) -->
                        <div id="tier2-stars" class="hidden flex items-center gap-1 ml-2 pl-2 border-l border-gray-300">
                            <span class="text-xs text-purple-600 font-medium">T2:</span>
                            <span class="flex items-center gap-0.5" title="Paragraph Gold">
                                <span class="text-yellow-400">‚òÖ</span>
                                <span id="gold-count-t2" class="font-bold text-yellow-600 bg-yellow-100 px-1.5 py-0.5 rounded text-xs">0</span>
                            </span>
                            <span class="flex items-center gap-0.5" title="Paragraph Silver">
                                <span class="text-gray-400">‚òÖ</span>
                                <span id="silver-count-t2" class="font-bold text-gray-500 bg-gray-200 px-1.5 py-0.5 rounded text-xs">0</span>
                            </span>
                            <span class="flex items-center gap-0.5" title="Paragraph Bronze">
                                <span class="text-amber-600">‚òÖ</span>
                                <span id="bronze-count-t2" class="font-bold text-amber-700 bg-amber-100 px-1.5 py-0.5 rounded text-xs">0</span>
                            </span>
                            <span class="flex items-center gap-0.5" title="Paragraph Tin">
                                <span class="text-stone-400">‚òÖ</span>
                                <span id="tin-count-t2" class="font-bold text-stone-500 bg-stone-200 px-1.5 py-0.5 rounded text-xs">0</span>
                            </span>
                        </div>
                        <!-- Tooltip popup -->
                        <div class="absolute left-0 top-full mt-2 w-64 bg-gray-900 text-white text-xs rounded-lg p-3 shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                            <div class="font-bold mb-2">How to Earn Stars</div>
                            <div class="space-y-1">
                                <div><span class="text-yellow-400">‚òÖ Gold:</span> All 3 correct, <span class="font-bold">no hints</span></div>
                                <div><span class="text-gray-300">‚òÖ Silver:</span> All 3 correct, 1 hint used</div>
                                <div><span class="text-amber-400">‚òÖ Bronze:</span> All 3 correct, 2 hints used</div>
                                <div><span class="text-stone-400">‚òÖ Tin:</span> All 3 correct, 3 hints used</div>
                            </div>
                            <div class="mt-2 pt-2 border-t border-gray-700 text-gray-400">
                                Stars require all slope, intercept, and correlation answers to be Essentially Correct (E).
                            </div>
                            <!-- Arrow -->
                            <div class="absolute -top-1 left-4 w-2 h-2 bg-gray-900 transform rotate-45"></div>
                        </div>
                    </div>
                    <div class="streak-3part flex items-center gap-1">
                        <span class="text-gray-500">Slope:</span>
                        <span id="slope-streak" class="font-bold text-purple-600 bg-purple-100 px-2 py-0.5 rounded">0</span>
                    </div>
                    <div class="streak-3part flex items-center gap-1">
                        <span class="text-gray-500">Intercept:</span>
                        <span id="intercept-streak" class="font-bold text-blue-600 bg-blue-100 px-2 py-0.5 rounded">0</span>
                    </div>
                    <div class="streak-3part flex items-center gap-1">
                        <span class="text-gray-500">Correlation:</span>
                        <span id="correlation-streak" class="font-bold text-green-600 bg-green-100 px-2 py-0.5 rounded">0</span>
                    </div>
                    <!-- Paragraph Streak (hidden until paragraph mode active) -->
                    <div id="paragraph-streak-display" class="hidden flex items-center gap-1">
                        <span class="text-gray-500">Paragraph:</span>
                        <span id="paragraph-streak" class="font-bold text-indigo-600 bg-indigo-100 px-2 py-0.5 rounded">0</span>
                    </div>
                </div>
                <!-- Online Users Indicator -->
                <div id="online-indicator" class="relative">
                    <button id="online-btn" class="flex items-center gap-1.5 bg-green-50 hover:bg-green-100 text-green-700 px-3 py-1.5 rounded-lg transition-colors" title="Online users">
                        <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                        <span id="online-count" class="text-sm font-medium">0</span>
                        <span class="text-sm">online</span>
                    </button>
                    <!-- Dropdown for online users -->
                    <div id="online-dropdown" class="absolute right-0 top-full mt-1 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 hidden">
                        <div class="px-3 py-1 text-xs font-medium text-gray-500 uppercase tracking-wide border-b border-gray-100 mb-1">Online Now</div>
                        <div id="online-list" class="max-h-48 overflow-y-auto">
                            <!-- Users will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Rank & Progress Display -->
                <div id="rank-display" class="flex items-center gap-2 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg px-3 py-1.5">
                    <span id="rank-icon" class="text-lg">üìä</span>
                    <div class="flex flex-col">
                        <span id="rank-name" class="text-xs font-semibold text-gray-700">Novice</span>
                        <div class="w-20 h-1.5 bg-gray-200 rounded-full overflow-hidden">
                            <div id="rank-progress-bar" class="h-full bg-purple-500 transition-all duration-500" style="width: 0%"></div>
                        </div>
                    </div>
                    <span id="rank-points" class="text-xs text-gray-500">0 pts</span>
                </div>

                <!-- Class Time Button (Teacher Only) -->
                <button id="class-time-btn" class="hidden flex items-center gap-1.5 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-3 py-1.5 rounded-lg transition-all shadow-md" title="Start Class Time">
                    <span class="text-lg">üîî</span>
                    <span class="text-sm font-medium">Class Time</span>
                </button>

                <!-- User Display -->
                <div id="user-display" class="flex items-center gap-2 bg-gray-50 rounded-full px-3 py-1 cursor-pointer hover:bg-gray-100 transition-colors" title="Click to change username">
                    <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                    <span id="current-username" class="text-sm font-medium text-gray-700">...</span>
                    <span id="teacher-badge" class="hidden text-xs bg-purple-600 text-white px-1.5 py-0.5 rounded">TEACHER</span>
                </div>

                <!-- Leaderboard Button -->
                <button id="leaderboard-btn" class="flex items-center gap-1.5 bg-yellow-50 hover:bg-yellow-100 text-yellow-700 px-3 py-1.5 rounded-lg transition-colors" title="View Class Leaderboard">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM14 11a1 1 0 011 1v1h1a1 1 0 110 2h-1v1a1 1 0 11-2 0v-1h-1a1 1 0 110-2h1v-1a1 1 0 011-1z"/>
                    </svg>
                    <span class="text-sm font-medium">Leaderboard</span>
                </button>

                <!-- Settings Button -->
                <button id="settings-btn" class="p-2 hover:bg-gray-100 rounded-full transition-colors" title="Settings">
                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <!-- Class Time Banner (hidden by default) -->
    <div id="class-time-banner" class="hidden bg-gradient-to-r from-green-500 via-emerald-500 to-teal-500 text-white py-2 px-4 shadow-lg">
        <div class="max-w-6xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-3">
                <span class="text-2xl animate-pulse">üîî</span>
                <div>
                    <span class="font-bold">CLASS TIME ACTIVE</span>
                    <span id="class-time-timer" class="ml-2 font-mono bg-white/20 px-2 py-0.5 rounded">00:00</span>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <!-- Class Goal Progress -->
                <div class="flex items-center gap-2">
                    <span class="text-sm">Goal:</span>
                    <div class="w-32 h-4 bg-white/30 rounded-full overflow-hidden">
                        <div id="class-goal-bar" class="h-full bg-yellow-400 transition-all duration-500" style="width: 0%"></div>
                    </div>
                    <span class="text-sm font-bold">
                        <span id="class-stars-earned">0</span>/<span id="class-goal-target">3</span> ‚≠ê
                    </span>
                </div>
                <button id="end-class-time-btn" class="hidden bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded-lg text-sm font-medium transition-colors">
                    End Class
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="max-w-4xl mx-auto px-4 py-6">
        <!-- Scenario Card (Sticky) -->
        <div class="bg-white rounded-xl shadow-lg p-4 mb-6 scenario-sticky border-b-2 border-purple-200">
            <div class="flex justify-between items-center gap-4">
                <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-3 mb-2">
                        <span class="text-xs text-gray-500 uppercase tracking-wide">Scenario:</span>
                        <h2 id="scenario-title" class="text-base font-semibold text-gray-800 truncate"></h2>
                    </div>
                    <div class="flex flex-wrap items-center gap-3 text-sm">
                        <div class="bg-purple-50 rounded px-2 py-1">
                            <span class="text-purple-600 font-medium">≈∑ = </span>
                            <span id="equation-display" class="text-gray-800 katex-like"></span>
                        </div>
                        <div class="bg-blue-50 rounded px-2 py-1">
                            <span class="text-blue-600 font-medium">r = </span>
                            <span id="correlation-display" class="text-gray-800 katex-like"></span>
                        </div>
                        <div id="context-details" class="text-xs text-gray-600"></div>
                    </div>
                </div>
                <div class="flex flex-col items-center gap-2">
                    <div id="scatterplot-container" class="flex-shrink-0">
                        <!-- SVG scatterplot will be inserted here -->
                    </div>
                    <button id="visualize-btn" class="text-xs text-purple-600 hover:text-purple-800 hover:underline flex items-center gap-1" title="Open 3D Z-Score Explorer">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                        </svg>
                        Explore in 3D
                    </button>
                </div>
            </div>

        </div>

        <!-- Mode Tabs (hidden until unlocked) -->
        <div id="mode-tabs" class="hidden flex justify-center mb-4">
            <div class="bg-gray-100 rounded-lg p-1 flex gap-1">
                <button id="mode-3part" class="px-4 py-2 rounded-md text-sm font-medium bg-white shadow text-purple-700 transition-all">
                    3-Part
                </button>
                <button id="mode-paragraph" class="px-4 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-gray-800 transition-all">
                    Full Paragraph
                </button>
            </div>
        </div>

        <!-- 3-Part Input Section -->
        <div id="three-part-section" class="space-y-4 mb-6">
            <!-- Slope Interpretation -->
            <div id="slope-card" class="bg-white rounded-xl shadow-lg p-5 feedback-card">
                <div class="flex items-center justify-between mb-2">
                    <label class="font-semibold text-purple-700">1. Slope Interpretation</label>
                    <button class="hint-toggle text-gray-400 hover:text-purple-600 transition-colors" data-target="slope-hint">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </button>
                </div>
                <textarea id="slope-input" class="w-full border border-gray-300 rounded-lg p-3 h-32 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all" placeholder="Write your slope interpretation here..."></textarea>
                <div id="slope-hint" class="hint-text text-sm text-gray-500 bg-gray-50 rounded p-4 mt-3 leading-relaxed">
                    <strong>Sentence Frame:</strong> "For every increase of 1 [x-unit], the predicted [y-variable] increases/decreases by [|b|] [y-units], on average."
                </div>
                <div id="slope-feedback" class="mt-3 hidden"></div>
            </div>

            <!-- Y-Intercept Interpretation -->
            <div id="intercept-card" class="bg-white rounded-xl shadow-lg p-5 feedback-card">
                <div class="flex items-center justify-between mb-2">
                    <label class="font-semibold text-blue-700">2. Y-Intercept Interpretation</label>
                    <button class="hint-toggle text-gray-400 hover:text-blue-600 transition-colors" data-target="intercept-hint">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </button>
                </div>
                <textarea id="intercept-input" class="w-full border border-gray-300 rounded-lg p-3 h-32 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all" placeholder="Write your y-intercept interpretation here..."></textarea>
                <div id="intercept-hint" class="hint-text text-sm text-gray-500 bg-gray-50 rounded p-4 mt-3 leading-relaxed">
                    <strong>Sentence Frame:</strong> "When [x-variable] is 0 [x-units], the predicted [y-variable] is [a] [y-units]."
                    <br><br>
                    <em>OR</em> "The y-intercept has no meaningful interpretation because [x=0 is impossible/outside the domain]."
                </div>
                <div id="intercept-feedback" class="mt-3 hidden"></div>
            </div>

            <!-- Correlation Interpretation -->
            <div id="correlation-card" class="bg-white rounded-xl shadow-lg p-5 feedback-card">
                <div class="flex items-center justify-between mb-2">
                    <label class="font-semibold text-green-700">3. Correlation Interpretation</label>
                    <button class="hint-toggle text-gray-400 hover:text-green-600 transition-colors" data-target="correlation-hint">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </button>
                </div>
                <textarea id="correlation-input" class="w-full border border-gray-300 rounded-lg p-3 h-32 focus:border-green-500 focus:ring-2 focus:ring-green-200 transition-all" placeholder="Write your correlation interpretation here..."></textarea>
                <div id="correlation-hint" class="hint-text text-sm text-gray-500 bg-gray-50 rounded p-4 mt-3 leading-relaxed">
                    <strong>Sentence Frame:</strong> "There is a [weak/moderate/strong], [positive/negative], linear relationship between [x-variable] and [y-variable]."
                </div>
                <div id="correlation-feedback" class="mt-3 hidden"></div>
            </div>
        </div>

        <!-- Paragraph Input Section (hidden by default) -->
        <div id="paragraph-section" class="hidden mb-6">
            <div id="paragraph-card" class="bg-white rounded-xl shadow-lg p-5 feedback-card">
                <div class="flex items-center justify-between mb-2">
                    <label class="font-semibold text-purple-700">Full LSRL Conclusion</label>
                    <button class="hint-toggle text-gray-400 hover:text-purple-600 transition-colors" data-target="paragraph-hint">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </button>
                </div>
                <textarea id="paragraph-input" class="w-full border border-gray-300 rounded-lg p-3 h-48 focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all" placeholder="Write your complete LSRL conclusion paragraph here. Include interpretations of the slope, y-intercept, and correlation coefficient."></textarea>
                <div id="paragraph-hint" class="hint-text text-sm text-gray-500 bg-gray-50 rounded p-4 mt-3 leading-relaxed">
                    <strong>Paragraph Frame:</strong><br><br>
                    "For every increase of 1 [x-unit], the predicted [y-variable] increases/decreases by [|b|] [y-units], on average. When [x-variable] is 0 [x-units], the predicted [y-variable] is [a] [y-units]. <em>(Or: The y-intercept has no meaningful interpretation because [x=0 is impossible/outside the domain].)</em> There is a [weak/moderate/strong], [positive/negative], linear relationship between [x-variable] and [y-variable]."
                </div>
                <div id="paragraph-feedback" class="mt-3 hidden"></div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex justify-center gap-4">
            <button id="grade-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold px-8 py-3 rounded-lg shadow-lg transition-all transform hover:scale-105">
                Grade My Conclusion
            </button>
            <button id="try-again-btn" style="display:none" class="bg-orange-500 hover:bg-orange-600 text-white font-semibold px-8 py-3 rounded-lg shadow-lg transition-all transform hover:scale-105">
                Try Again
            </button>
            <button id="next-btn" style="display:none" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-8 py-3 rounded-lg shadow-lg transition-all transform hover:scale-105">
                Next Scenario ‚Üí
            </button>
            <button id="skip-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold px-6 py-3 rounded-lg shadow transition-all">
                Skip
            </button>
        </div>

        <!-- AI Toggle & Hint Status -->
        <div class="mt-4 flex justify-center items-center gap-4">
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500">Keywords</span>
                <button id="ai-toggle" class="relative inline-flex h-5 w-9 items-center rounded-full transition-colors" title="Toggle AI grading">
                    <span class="sr-only">Enable AI grading</span>
                    <span id="ai-toggle-dot" class="inline-block h-3.5 w-3.5 transform rounded-full bg-white shadow transition-transform"></span>
                </button>
                <span class="text-xs text-gray-500">+ AI</span>
                <span id="grading-status" class="text-xs text-gray-400 ml-1"></span>
            </div>
            <div id="hint-status" class="flex items-center gap-1 text-xs">
                <span class="text-yellow-400">‚òÖ</span>
                <span id="potential-star" class="text-yellow-600 font-medium">Gold</span>
            </div>
        </div>
    </main>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-800">Settings</h3>
                <button id="close-settings" class="text-gray-400 hover:text-gray-600">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Default Grading Mode</label>
                    <select id="ai-provider" class="w-full border border-gray-300 rounded-lg p-2">
                        <option value="server">Server AI (Recommended)</option>
                        <option value="gemini">Google Gemini (Own Key)</option>
                        <option value="groq">Groq (Own Key)</option>
                        <option value="none">Keyword Matching Only</option>
                    </select>
                    <p id="server-mode-note" class="text-xs text-green-600 mt-1">No API key needed - grading handled by server.</p>
                </div>

                <div id="api-keys-section" class="border-t pt-4 hidden">
                    <label class="block text-sm font-medium text-gray-700 mb-2">API Keys (for own key modes)</label>
                    <a href="https://youtu.be/MyyE05aUAmQ" target="_blank" class="inline-flex items-center gap-1 text-xs text-purple-600 hover:text-purple-800 mb-3">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                        Watch: How to set up API keys
                    </a>

                    <div class="mb-3">
                        <label class="block text-xs text-gray-600 mb-1">
                            Gemini Key
                            <a href="https://aistudio.google.com/apikey" target="_blank" class="text-blue-600 hover:underline ml-1">(get free key)</a>
                        </label>
                        <input type="password" id="gemini-key-input" class="w-full border border-gray-300 rounded-lg p-2 text-sm" placeholder="AIza...">
                    </div>

                    <div>
                        <label class="block text-xs text-gray-600 mb-1">
                            Groq Key
                            <a href="https://console.groq.com/keys" target="_blank" class="text-blue-600 hover:underline ml-1">(get free key)</a>
                        </label>
                        <input type="password" id="groq-key-input" class="w-full border border-gray-300 rounded-lg p-2 text-sm" placeholder="gsk_...">
                    </div>

                    <p class="text-xs text-gray-400 mt-2">Keys are stored locally in your browser only.</p>
                </div>

                <div class="border-t pt-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Sound Effects</label>
                    <div class="flex items-center gap-3">
                        <button id="sound-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-purple-600 transition-colors">
                            <span id="sound-toggle-dot" class="inline-block h-4 w-4 transform rounded-full bg-white shadow transition-transform translate-x-6"></span>
                        </button>
                        <span class="text-sm text-gray-600">Sound effects enabled</span>
                    </div>
                </div>

                <div class="border-t pt-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Progress</label>
                    <button id="reset-streaks" class="text-sm text-red-600 hover:text-red-800">Reset All Streaks & Stars</button>
                </div>
            </div>

            <div class="mt-6 flex justify-end">
                <button id="save-settings" class="bg-purple-600 hover:bg-purple-700 text-white font-medium px-4 py-2 rounded-lg">
                    Save Settings
                </button>
            </div>
        </div>
    </div>

    <!-- Username Modal (shown on first visit) -->
    <div id="username-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-2xl shadow-xl w-full max-w-md mx-4 overflow-hidden">
            <div class="bg-gradient-to-r from-purple-600 to-blue-600 px-6 py-4 flex items-center justify-between">
                <div>
                    <h2 id="username-modal-title" class="text-xl font-bold text-white">Welcome to LSRL Trainer!</h2>
                    <p id="username-modal-subtitle" class="text-purple-100 text-sm mt-1">Choose a username to track your progress</p>
                </div>
                <button id="close-username-modal" class="p-2 hover:bg-white/20 rounded-full transition-colors hidden" title="Close">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="p-6">
                <!-- New User Section -->
                <div id="new-user-section">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Your Username</label>
                    <div class="flex gap-2 mb-3">
                        <input type="text" id="username-input" class="flex-1 border border-gray-300 rounded-lg p-2.5 text-lg font-medium" placeholder="Mango_Tiger" readonly>
                        <button id="regenerate-username" class="p-2.5 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" title="Generate new username">
                            <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Your Name <span class="text-gray-400 font-normal">(optional)</span></label>
                        <input type="text" id="realname-input" class="w-full border border-gray-300 rounded-lg p-2" placeholder="First name or nickname">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Password <span class="text-gray-400 font-normal">(to log back in)</span></label>
                        <input type="password" id="password-input" class="w-full border border-gray-300 rounded-lg p-2" placeholder="Choose a password">
                    </div>
                </div>

                <!-- Divider -->
                <div class="flex items-center gap-3 my-4">
                    <div class="flex-1 border-t border-gray-200"></div>
                    <span class="text-sm text-gray-400">or sign in</span>
                    <div class="flex-1 border-t border-gray-200"></div>
                </div>

                <!-- Existing User Section -->
                <div id="existing-user-section">
                    <div class="mb-3">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Existing User</label>
                        <select id="existing-user-select" class="w-full border border-gray-300 rounded-lg p-2 bg-white">
                            <option value="">Select your username...</option>
                        </select>
                    </div>

                    <div id="existing-password-section" class="mb-4 hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Password</label>
                        <input type="password" id="existing-password-input" class="w-full border border-gray-300 rounded-lg p-2" placeholder="Enter your password">
                    </div>
                </div>

                <button id="username-submit" class="w-full bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white font-medium py-3 rounded-lg transition-all">
                    Let's Go!
                </button>

                <!-- Teacher Login -->
                <div class="mt-4 pt-4 border-t border-gray-200">
                    <button id="teacher-login-btn" class="w-full text-sm text-gray-500 hover:text-purple-600 transition-colors">
                        I'm a Teacher ‚Üí
                    </button>
                </div>

                <!-- Teacher Password Section (hidden by default) -->
                <div id="teacher-password-section" class="hidden mt-4 p-4 bg-purple-50 rounded-lg">
                    <label class="block text-sm font-medium text-purple-700 mb-2">Teacher Password</label>
                    <input type="password" id="teacher-password-input" class="w-full border border-purple-300 rounded-lg p-2 mb-3" placeholder="Enter teacher password">
                    <button id="teacher-submit-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 rounded-lg transition-colors">
                        Enter as Teacher
                    </button>
                </div>

                <p id="username-error" class="text-red-500 text-sm mt-2 hidden"></p>
            </div>
        </div>
    </div>

    <!-- Leaderboard Slide-out Panel -->
    <div id="leaderboard-panel" class="fixed inset-y-0 right-0 w-full max-w-md bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300 ease-in-out">
        <div class="h-full flex flex-col">
            <!-- Header -->
            <div class="bg-gradient-to-r from-yellow-400 to-orange-400 px-6 py-4 flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <span class="text-2xl">üèÜ</span>
                    <h2 class="text-xl font-bold text-white">Class Leaderboard</h2>
                </div>
                <button id="close-leaderboard" class="p-2 hover:bg-white/20 rounded-full transition-colors">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <!-- Period Filter -->
            <div class="px-6 py-3 bg-gray-50 border-b flex gap-2">
                <button data-period="today" class="leaderboard-period-btn px-3 py-1 text-sm rounded-full bg-white border border-gray-200 text-gray-600 hover:border-yellow-400">Today</button>
                <button data-period="week" class="leaderboard-period-btn px-3 py-1 text-sm rounded-full bg-white border border-gray-200 text-gray-600 hover:border-yellow-400">This Week</button>
                <button data-period="all" class="leaderboard-period-btn px-3 py-1 text-sm rounded-full bg-yellow-400 text-white border border-yellow-400">All Time</button>
            </div>

            <!-- Leaderboard Content -->
            <div id="leaderboard-content" class="flex-1 overflow-y-auto p-4">
                <div id="leaderboard-loading" class="flex items-center justify-center h-32">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-500"></div>
                </div>
                <div id="leaderboard-list" class="space-y-3 hidden">
                    <!-- Entries will be populated here -->
                </div>
                <div id="leaderboard-empty" class="text-center text-gray-500 py-8 hidden">
                    <span class="text-4xl block mb-2">üìä</span>
                    <p>No data yet. Be the first to earn a star!</p>
                </div>
                <div id="leaderboard-offline" class="text-center text-gray-500 py-8 hidden">
                    <span class="text-4xl block mb-2">üì°</span>
                    <p>Connect to the server to see the leaderboard.</p>
                    <p class="text-sm mt-2">Set RAILWAY_URL in the code to enable multiplayer.</p>
                </div>
            </div>

            <!-- Legend -->
            <div class="px-6 py-3 bg-gray-50 border-t text-xs text-gray-500">
                <div class="flex items-center gap-4 justify-center">
                    <span title="Gold (4 pts)">‚≠ê = 4pts</span>
                    <span title="Silver (3 pts)">ü•à = 3pts</span>
                    <span title="Bronze (2 pts)">ü•â = 2pts</span>
                    <span title="Tin (1 pt)">‚óã = 1pt</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaderboard Backdrop -->
    <div id="leaderboard-backdrop" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>

    <script>
    // ============== DEXIE DATABASE (IndexedDB) ==============
    const db = new Dexie('LSRLTrainer');

    db.version(1).stores({
        // Current user identity: { key: 'identity', value: { username, realName, ... } }
        meta: 'key',
        // Local progress cache (mirrors Supabase when connected)
        progress: '++id, username, completed_at',
        // Cached user settings (API keys backup)
        settings: 'username',
        // Sync tracking: { key: 'lastSync', value: timestamp }
        sync: 'key'
    });

    // Database helper functions
    const dbHelpers = {
        // Get current user identity
        async getIdentity() {
            const record = await db.meta.get('identity');
            return record?.value || null;
        },

        // Set current user identity
        async setIdentity(identity) {
            await db.meta.put({ key: 'identity', value: identity });
        },

        // Save progress locally
        async saveProgress(progressData) {
            const record = {
                ...progressData,
                completed_at: new Date().toISOString()
            };
            return await db.progress.add(record);
        },

        // Get all progress for a user
        async getProgress(username) {
            return await db.progress.where('username').equals(username).toArray();
        },

        // Get user stats
        async getStats(username) {
            const progress = await this.getProgress(username);
            const stats = {
                totalStars: { gold: 0, silver: 0, bronze: 0, tin: 0 },
                totalAttempts: progress.length,
                perfectRuns: 0,
                streaks: { slope: 0, intercept: 0, correlation: 0 }
            };

            for (const p of progress) {
                if (p.star_type && stats.totalStars[p.star_type] !== undefined) {
                    stats.totalStars[p.star_type]++;
                }
                if (p.all_correct) stats.perfectRuns++;
            }

            return stats;
        },

        // Save settings locally
        async saveSettings(username, settings) {
            await db.settings.put({ username, ...settings, updated_at: new Date().toISOString() });
        },

        // Get settings for a user
        async getSettings(username) {
            return await db.settings.get(username);
        },

        // Migrate from localStorage (one-time migration)
        async migrateFromLocalStorage() {
            const migrated = localStorage.getItem('dexie_migrated');
            if (migrated) return;

            console.log('Migrating localStorage to IndexedDB...');

            // Migrate streaks
            const streaks = {
                slope: parseInt(localStorage.getItem('slopeStreak') || '0'),
                intercept: parseInt(localStorage.getItem('interceptStreak') || '0'),
                correlation: parseInt(localStorage.getItem('correlationStreak') || '0')
            };
            await db.meta.put({ key: 'streaks', value: streaks });

            // Migrate stars
            const stars = {
                gold: parseInt(localStorage.getItem('goldStars') || '0'),
                silver: parseInt(localStorage.getItem('silverStars') || '0'),
                bronze: parseInt(localStorage.getItem('bronzeStars') || '0'),
                tin: parseInt(localStorage.getItem('tinStars') || '0')
            };
            await db.meta.put({ key: 'stars', value: stars });

            // Migrate API settings
            const apiSettings = {
                provider: localStorage.getItem('apiProvider') || 'gemini',
                geminiKey: localStorage.getItem('geminiApiKey') || '',
                groqKey: localStorage.getItem('groqApiKey') || ''
            };
            await db.meta.put({ key: 'apiSettings', value: apiSettings });

            localStorage.setItem('dexie_migrated', 'true');
            console.log('Migration complete!');
        }
    };

    // Run migration on load
    dbHelpers.migrateFromLocalStorage().catch(err => {
        console.error('Migration failed:', err);
    });

    // ============== USERNAME GENERATOR ==============
    const FRUITS = [
        'Apple', 'Mango', 'Kiwi', 'Strawberry', 'Banana',
        'Orange', 'Grape', 'Peach', 'Cherry', 'Lemon',
        'Lime', 'Melon', 'Papaya', 'Coconut', 'Pineapple'
    ];

    const ANIMALS = [
        'Tiger', 'Bear', 'Wolf', 'Dolphin', 'Eagle',
        'Panda', 'Koala', 'Fox', 'Owl', 'Hawk',
        'Lion', 'Shark', 'Whale', 'Otter', 'Falcon'
    ];

    function generateUsername() {
        const fruit = FRUITS[Math.floor(Math.random() * FRUITS.length)];
        const animal = ANIMALS[Math.floor(Math.random() * ANIMALS.length)];
        return `${fruit}_${animal}`;
    }

    // Generate avatar emoji from username
    function getAvatarForUsername(username) {
        const fruitEmojis = {
            'Apple': 'üçé', 'Mango': 'ü•≠', 'Kiwi': 'ü•ù', 'Strawberry': 'üçì', 'Banana': 'üçå',
            'Orange': 'üçä', 'Grape': 'üçá', 'Peach': 'üçë', 'Cherry': 'üçí', 'Lemon': 'üçã',
            'Lime': 'üçã', 'Melon': 'üçà', 'Papaya': 'ü•≠', 'Coconut': 'ü••', 'Pineapple': 'üçç'
        };
        const animalEmojis = {
            'Tiger': 'üêØ', 'Bear': 'üêª', 'Wolf': 'üê∫', 'Dolphin': 'üê¨', 'Eagle': 'ü¶Ö',
            'Panda': 'üêº', 'Koala': 'üê®', 'Fox': 'ü¶ä', 'Owl': 'ü¶â', 'Hawk': 'ü¶Ö',
            'Lion': 'ü¶Å', 'Shark': 'ü¶à', 'Whale': 'üêã', 'Otter': 'ü¶¶', 'Falcon': 'ü¶Ö'
        };

        // Try to parse Fruit_Animal pattern
        const parts = username.split('_');
        if (parts.length >= 2) {
            const fruit = fruitEmojis[parts[0]] || '';
            const animal = animalEmojis[parts[1]] || '';
            if (fruit && animal) return fruit + animal;
            if (fruit) return fruit;
            if (animal) return animal;
        }

        // Fallback: generate from hash of username
        const emojis = ['üéì', 'üìö', '‚úèÔ∏è', 'üìä', 'üéØ', '‚≠ê', 'üåü', 'üí´', 'üî•', 'üí™'];
        let hash = 0;
        for (let i = 0; i < username.length; i++) {
            hash = ((hash << 5) - hash) + username.charCodeAt(i);
            hash = hash & hash;
        }
        return emojis[Math.abs(hash) % emojis.length];
    }

    // Current user state
    let currentUser = null;
    let isTeacherMode = false;
    const TEACHER_PASSWORD = 'stats123'; // Change this!

    // ============== RANK SYSTEM ==============
    const RANKS = [
        { name: 'Novice', minPoints: 0, color: 'gray', icon: 'üìä' },
        { name: 'Apprentice', minPoints: 10, color: 'green', icon: 'üìà' },
        { name: 'Analyst', minPoints: 30, color: 'blue', icon: 'üîç' },
        { name: 'Statistician', minPoints: 60, color: 'purple', icon: 'üéØ' },
        { name: 'Expert', minPoints: 100, color: 'orange', icon: '‚≠ê' },
        { name: 'Master', minPoints: 150, color: 'yellow', icon: 'üëë' },
        { name: 'Legend', minPoints: 250, color: 'red', icon: 'üèÜ' }
    ];

    function getWeightedScore(stars) {
        return (stars.gold * 4) + (stars.silver * 3) + (stars.bronze * 2) + (stars.tin * 1);
    }

    function getCurrentRank(stars) {
        const score = getWeightedScore(stars);
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (score >= rank.minPoints) {
                currentRank = rank;
            }
        }
        return currentRank;
    }

    function getNextRank(stars) {
        const score = getWeightedScore(stars);
        for (const rank of RANKS) {
            if (score < rank.minPoints) {
                return rank;
            }
        }
        return null; // Already at max rank
    }

    function getRankProgress(stars) {
        const score = getWeightedScore(stars);
        const current = getCurrentRank(stars);
        const next = getNextRank(stars);
        if (!next) return 100; // Max rank
        const progressInRank = score - current.minPoints;
        const rankSpan = next.minPoints - current.minPoints;
        return Math.floor((progressInRank / rankSpan) * 100);
    }

    // ============== SOUND ENGINE (Web Audio API Synth) ==============
    const soundEngine = {
        ctx: null,
        enabled: localStorage.getItem('soundEnabled') !== 'false', // Default to true

        init() {
            // Create audio context on first user interaction
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
        },

        // Play a note with envelope
        playNote(freq, duration = 0.2, type = 'sine', volume = 0.3) {
            if (!this.enabled || !this.ctx) return;

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(this.ctx.destination);

            const now = this.ctx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            osc.start(now);
            osc.stop(now + duration);
        },

        // Play a chord
        playChord(freqs, duration = 0.3, type = 'sine') {
            freqs.forEach(f => this.playNote(f, duration, type, 0.15));
        },

        // Sound effects
        correct() {
            // Happy ascending arpeggio
            this.playNote(523, 0.15); // C5
            setTimeout(() => this.playNote(659, 0.15), 100); // E5
            setTimeout(() => this.playNote(784, 0.2), 200); // G5
        },

        incorrect() {
            // Descending minor
            this.playNote(400, 0.15, 'triangle');
            setTimeout(() => this.playNote(350, 0.2, 'triangle'), 100);
        },

        goldStar() {
            // Triumphant fanfare
            this.playChord([523, 659, 784], 0.2); // C major
            setTimeout(() => this.playChord([587, 740, 880], 0.2), 200); // D major
            setTimeout(() => this.playChord([659, 830, 988], 0.4), 400); // E major
        },

        silverStar() {
            this.playChord([440, 554, 659], 0.3); // A major
        },

        bronzeStar() {
            this.playNote(523, 0.2);
            setTimeout(() => this.playNote(659, 0.2), 150);
        },

        tinStar() {
            this.playNote(440, 0.2, 'triangle');
        },

        notification() {
            // Soft chime for others' achievements
            this.playNote(880, 0.1, 'sine', 0.1);
            setTimeout(() => this.playNote(1100, 0.15, 'sine', 0.1), 80);
        },

        rankUp() {
            // Epic rank up sound
            this.playChord([262, 330, 392], 0.15);
            setTimeout(() => this.playChord([294, 370, 440], 0.15), 150);
            setTimeout(() => this.playChord([330, 415, 494], 0.15), 300);
            setTimeout(() => this.playChord([392, 494, 587], 0.4), 450);
        },

        streak(count) {
            // Higher pitch for higher streaks
            const baseFreq = 400 + (count * 50);
            this.playNote(Math.min(baseFreq, 1200), 0.15, 'square', 0.1);
        },

        classTimeStart() {
            // School bell sound
            this.playNote(659, 0.3);
            setTimeout(() => this.playNote(659, 0.3), 400);
            setTimeout(() => this.playNote(659, 0.5), 800);
        }
    };

    // Username modal controller
    const usernameModal = {
        modal: null,
        usernameInput: null,
        realnameInput: null,
        passwordInput: null,
        existingSelect: null,
        existingPasswordInput: null,
        existingPasswordSection: null,
        submitBtn: null,
        errorEl: null,

        init() {
            this.modal = document.getElementById('username-modal');
            this.usernameInput = document.getElementById('username-input');
            this.realnameInput = document.getElementById('realname-input');
            this.passwordInput = document.getElementById('password-input');
            this.existingSelect = document.getElementById('existing-user-select');
            this.existingPasswordInput = document.getElementById('existing-password-input');
            this.existingPasswordSection = document.getElementById('existing-password-section');
            this.submitBtn = document.getElementById('username-submit');
            this.errorEl = document.getElementById('username-error');

            // Generate initial username
            this.usernameInput.value = generateUsername();

            // Regenerate button
            document.getElementById('regenerate-username').addEventListener('click', () => {
                this.usernameInput.value = generateUsername();
            });

            // Existing user dropdown change
            this.existingSelect.addEventListener('change', () => {
                if (this.existingSelect.value) {
                    this.existingPasswordSection.classList.remove('hidden');
                } else {
                    this.existingPasswordSection.classList.add('hidden');
                }
            });

            // Submit button
            this.submitBtn.addEventListener('click', () => this.submit());

            // Close button (only visible when reopening, not on first visit)
            document.getElementById('close-username-modal').addEventListener('click', () => {
                this.hide();
            });

            // User display click (re-open modal)
            document.getElementById('user-display').addEventListener('click', () => {
                this.show(true); // true = reopening (show close button)
            });

            // Teacher login button
            document.getElementById('teacher-login-btn').addEventListener('click', () => {
                document.getElementById('teacher-password-section').classList.toggle('hidden');
            });

            // Teacher submit button
            document.getElementById('teacher-submit-btn').addEventListener('click', () => {
                const password = document.getElementById('teacher-password-input').value;
                if (password === TEACHER_PASSWORD) {
                    isTeacherMode = true;
                    document.getElementById('teacher-badge').classList.remove('hidden');
                    document.getElementById('teacher-password-section').classList.add('hidden');
                    document.getElementById('teacher-password-input').value = '';
                    this.hide();
                    soundEngine.init();
                    soundEngine.classTimeStart();
                    showTeacherControls();
                } else {
                    this.showError('Incorrect teacher password');
                }
            });
        },

        async show(isReopen = false) {
            this.modal.classList.remove('hidden');
            this.errorEl.classList.add('hidden');

            const closeBtn = document.getElementById('close-username-modal');
            const title = document.getElementById('username-modal-title');
            const subtitle = document.getElementById('username-modal-subtitle');

            if (isReopen && currentUser) {
                // Show close button and change title when reopening
                closeBtn.classList.remove('hidden');
                title.textContent = 'Switch Account';
                subtitle.textContent = `Currently: ${currentUser.username}`;
            } else {
                // First visit - hide close button
                closeBtn.classList.add('hidden');
                title.textContent = 'Welcome to LSRL Trainer!';
                subtitle.textContent = 'Choose a username to track your progress';
            }

            // Refresh user list from server
            await this.loadUserList();
        },

        async loadUserList() {
            if (!RAILWAY_URL) return;

            const users = await railwayClient.getUsers();
            if (users && Array.isArray(users)) {
                this.existingSelect.innerHTML = '<option value="">Select your username...</option>';
                for (const user of users) {
                    const option = document.createElement('option');
                    option.value = user.username;
                    option.textContent = user.real_name ? `${user.username} (${user.real_name})` : user.username;
                    this.existingSelect.appendChild(option);
                }
            }
        },

        hide() {
            this.modal.classList.add('hidden');
        },

        async submit() {
            this.errorEl.classList.add('hidden');

            // Check if signing in as existing user
            if (this.existingSelect.value) {
                const username = this.existingSelect.value;
                const password = this.existingPasswordInput.value;

                if (!password) {
                    this.showError('Please enter your password');
                    return;
                }

                // Verify with server if connected
                if (RAILWAY_URL) {
                    const result = await railwayClient.verifyUser(username, password);
                    if (!result?.valid) {
                        this.showError(result?.error || 'Invalid credentials');
                        return;
                    }
                }

                // Set as current user
                currentUser = { username, password };
                await dbHelpers.setIdentity(currentUser);
                this.updateDisplay();
                this.hide();

                // Connect WebSocket after login
                railwayClient.connect();
                return;
            }

            // Creating new user
            const username = this.usernameInput.value.trim();
            const realName = this.realnameInput.value.trim();
            const password = this.passwordInput.value;

            if (!username) {
                this.showError('Username is required');
                return;
            }

            if (!password) {
                this.showError('Please choose a password');
                return;
            }

            // Try to create user on server (if connected)
            if (RAILWAY_URL) {
                const result = await railwayClient.createUser(username, realName, password);
                if (result?.error) {
                    this.showError(result.error);
                    return;
                }
            }

            // Set as current user
            currentUser = { username, realName, password };
            await dbHelpers.setIdentity(currentUser);
            this.updateDisplay();
            this.hide();

            // Connect WebSocket after login
            railwayClient.connect();
        },

        showError(msg) {
            this.errorEl.textContent = msg;
            this.errorEl.classList.remove('hidden');
        },

        updateDisplay() {
            const display = document.getElementById('current-username');
            display.textContent = currentUser?.username || '...';
        },

        async checkAndShow() {
            // Check if user already has identity
            const identity = await dbHelpers.getIdentity();
            if (identity?.username) {
                currentUser = identity;
                this.updateDisplay();
                // Don't show modal - user is already logged in
                // Connect WebSocket
                railwayClient.connect();
            } else {
                // First visit - show modal (will also load user list)
                await this.show(false);
            }
        }
    };

    // ============== RAILWAY SERVER CLIENT ==============
    // Configure your Railway server URL here (or leave null for local-only mode)
    const RAILWAY_URL = 'https://lrsl-driller-production.up.railway.app'; // e.g., 'https://your-app.railway.app'

    const railwayClient = {
        ws: null,
        connected: false,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        heartbeatInterval: null,
        onlineUsers: [],

        get baseUrl() {
            return RAILWAY_URL;
        },

        get wsUrl() {
            if (!RAILWAY_URL) return null;
            return RAILWAY_URL.replace('https://', 'wss://').replace('http://', 'ws://');
        },

        // REST API helpers
        async fetch(endpoint, options = {}) {
            if (!this.baseUrl) return null;

            try {
                const response = await fetch(`${this.baseUrl}${endpoint}`, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                return await response.json();
            } catch (err) {
                console.warn('Railway API error:', err);
                return null;
            }
        },

        // User API
        async getUsers() {
            return await this.fetch('/api/users');
        },

        async createUser(username, realName, password) {
            return await this.fetch('/api/users', {
                method: 'POST',
                body: JSON.stringify({ username, real_name: realName, password })
            });
        },

        async verifyUser(username, password) {
            return await this.fetch('/api/users/verify', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            });
        },

        // Progress API
        async saveProgress(progressData) {
            return await this.fetch('/api/progress', {
                method: 'POST',
                body: JSON.stringify(progressData)
            });
        },

        async getLeaderboard(period = 'all', limit = 20) {
            return await this.fetch(`/api/leaderboard?period=${period}&limit=${limit}`);
        },

        // Settings API
        async getSettings(username, password) {
            return await this.fetch(`/api/settings/${username}`, {
                headers: { 'x-password': password }
            });
        },

        async saveSettings(username, password, settings) {
            return await this.fetch(`/api/settings/${username}`, {
                method: 'POST',
                headers: { 'x-password': password },
                body: JSON.stringify(settings)
            });
        },

        // WebSocket connection
        connect() {
            if (!this.wsUrl || this.ws) return;

            try {
                this.ws = new WebSocket(this.wsUrl);

                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.connected = true;
                    this.reconnectAttempts = 0;

                    // Identify ourselves
                    if (currentUser?.username) {
                        this.identify(currentUser.username);
                    }

                    // Start heartbeat
                    this.heartbeatInterval = setInterval(() => {
                        if (this.ws?.readyState === WebSocket.OPEN) {
                            this.send({ type: 'heartbeat', username: currentUser?.username });
                        }
                    }, 30000);

                    // Update UI
                    this.updateOnlineIndicator(true);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (err) {
                        console.warn('WebSocket message parse error:', err);
                    }
                };

                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.connected = false;
                    this.ws = null;
                    clearInterval(this.heartbeatInterval);
                    this.updateOnlineIndicator(false);

                    // Attempt reconnect
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.reconnectAttempts++;
                        setTimeout(() => this.connect(), 5000 * this.reconnectAttempts);
                    }
                };

                this.ws.onerror = (err) => {
                    console.warn('WebSocket error:', err);
                };
            } catch (err) {
                console.warn('WebSocket connection failed:', err);
            }
        },

        send(message) {
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify(message));
            }
        },

        identify(username) {
            this.send({ type: 'identify', username });
        },

        notifyStarEarned(username, starType, scenarioTopic) {
            this.send({
                type: 'star_earned',
                username,
                star_type: starType,
                scenario_topic: scenarioTopic
            });
        },

        handleMessage(message) {
            switch (message.type) {
                case 'presence_snapshot':
                    this.onlineUsers = message.users || [];
                    this.updatePresenceDisplay();
                    break;

                case 'user_online':
                    if (!this.onlineUsers.includes(message.username)) {
                        this.onlineUsers.push(message.username);
                    }
                    this.updatePresenceDisplay();
                    break;

                case 'user_offline':
                    this.onlineUsers = this.onlineUsers.filter(u => u !== message.username);
                    this.updatePresenceDisplay();
                    break;

                case 'star_earned':
                    // Don't show notification for own stars
                    if (message.username !== currentUser?.username) {
                        this.showStarNotification(message.username, message.star_type, message.scenario_topic);
                        soundEngine.init();
                        soundEngine.notification();
                    }
                    break;

                case 'leaderboard_update':
                    // Refresh leaderboard if it's open
                    if (typeof refreshLeaderboard === 'function') {
                        refreshLeaderboard();
                    }
                    break;

                case 'class_time_start':
                    // Teacher started class time - sync to all students
                    if (!classTime.active) {
                        if (message.goal) {
                            classTime.setGoal(message.goal);
                        }
                        classTime.start();
                    }
                    break;

                case 'class_time_end':
                    // Teacher ended class time
                    if (classTime.active && !isTeacherMode) {
                        // Only auto-end for students, teacher controls their own
                        classTime.end();
                    }
                    break;
            }
        },

        updateOnlineIndicator(connected) {
            const indicator = document.querySelector('#user-display .bg-green-400, #user-display .bg-gray-400');
            if (indicator) {
                if (connected) {
                    indicator.className = 'w-2 h-2 bg-green-400 rounded-full animate-pulse';
                } else {
                    indicator.className = 'w-2 h-2 bg-gray-400 rounded-full';
                }
            }
        },

        updatePresenceDisplay() {
            console.log('Online users:', this.onlineUsers);

            // Update online count
            const countEl = document.getElementById('online-count');
            if (countEl) {
                countEl.textContent = this.onlineUsers.length;
            }

            // Update online list dropdown
            const listEl = document.getElementById('online-list');
            if (listEl) {
                if (this.onlineUsers.length === 0) {
                    listEl.innerHTML = '<div class="px-3 py-2 text-sm text-gray-400 italic">No one else online</div>';
                } else {
                    listEl.innerHTML = this.onlineUsers.map(username => {
                        const isYou = username === currentUser?.username;
                        const avatar = getAvatarForUsername(username);
                        return `
                            <div class="px-3 py-1.5 flex items-center gap-2 ${isYou ? 'bg-purple-50' : 'hover:bg-gray-50'}">
                                <span class="text-lg" title="${username}">${avatar}</span>
                                <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                                <span class="text-sm text-gray-700">${username}</span>
                                ${isYou ? '<span class="text-xs text-purple-600 ml-auto">(you)</span>' : ''}
                            </div>
                        `;
                    }).join('');
                }
            }
        },

        showStarNotification(username, starType, scenarioTopic) {
            const starEmoji = {
                gold: '‚≠ê',
                silver: 'ü•à',
                bronze: 'ü•â',
                tin: '‚óã'
            };
            const avatar = getAvatarForUsername(username);

            const toast = document.createElement('div');
            toast.className = 'fixed top-20 right-4 bg-white rounded-lg shadow-xl p-4 z-50 animate-slide-in border-l-4 border-yellow-400';
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <span class="text-2xl">${avatar}</span>
                    <div>
                        <div class="flex items-center gap-1">
                            <span class="font-medium text-gray-800">${username}</span>
                            <span class="text-xl">${starEmoji[starType] || '‚≠ê'}</span>
                        </div>
                        <div class="text-sm text-gray-500">earned a ${starType} star on "${scenarioTopic}"</div>
                    </div>
                </div>
            `;

            document.body.appendChild(toast);

            // Auto-dismiss after 4 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                toast.style.transition = 'all 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        },

        disconnect() {
            if (this.ws) {
                this.ws.close();
                this.ws = null;
            }
            clearInterval(this.heartbeatInterval);
        }
    };

    // ============== LEADERBOARD CONTROLLER ==============
    const leaderboard = {
        panel: null,
        backdrop: null,
        list: null,
        loading: null,
        empty: null,
        offline: null,
        currentPeriod: 'all',
        isOpen: false,

        init() {
            this.panel = document.getElementById('leaderboard-panel');
            this.backdrop = document.getElementById('leaderboard-backdrop');
            this.list = document.getElementById('leaderboard-list');
            this.loading = document.getElementById('leaderboard-loading');
            this.empty = document.getElementById('leaderboard-empty');
            this.offline = document.getElementById('leaderboard-offline');

            // Open button
            document.getElementById('leaderboard-btn').addEventListener('click', () => this.open());

            // Close button
            document.getElementById('close-leaderboard').addEventListener('click', () => this.close());

            // Backdrop click
            this.backdrop.addEventListener('click', () => this.close());

            // Period buttons
            document.querySelectorAll('.leaderboard-period-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.currentPeriod = btn.dataset.period;
                    this.updatePeriodButtons();
                    this.refresh();
                });
            });
        },

        open() {
            this.isOpen = true;
            this.panel.classList.remove('translate-x-full');
            this.backdrop.classList.remove('hidden');
            this.refresh();
        },

        close() {
            this.isOpen = false;
            this.panel.classList.add('translate-x-full');
            this.backdrop.classList.add('hidden');
        },

        updatePeriodButtons() {
            document.querySelectorAll('.leaderboard-period-btn').forEach(btn => {
                if (btn.dataset.period === this.currentPeriod) {
                    btn.className = 'leaderboard-period-btn px-3 py-1 text-sm rounded-full bg-yellow-400 text-white border border-yellow-400';
                } else {
                    btn.className = 'leaderboard-period-btn px-3 py-1 text-sm rounded-full bg-white border border-gray-200 text-gray-600 hover:border-yellow-400';
                }
            });
        },

        async refresh() {
            // Show loading
            this.loading.classList.remove('hidden');
            this.list.classList.add('hidden');
            this.empty.classList.add('hidden');
            this.offline.classList.add('hidden');

            // Check if server is configured
            if (!RAILWAY_URL) {
                this.loading.classList.add('hidden');
                this.offline.classList.remove('hidden');
                return;
            }

            try {
                const data = await railwayClient.getLeaderboard(this.currentPeriod, 20);

                this.loading.classList.add('hidden');

                if (!data || data.length === 0) {
                    this.empty.classList.remove('hidden');
                    return;
                }

                this.renderList(data);
                this.list.classList.remove('hidden');
            } catch (err) {
                console.error('Failed to load leaderboard:', err);
                this.loading.classList.add('hidden');
                this.offline.classList.remove('hidden');
            }
        },

        renderList(data) {
            this.list.innerHTML = '';

            data.forEach((entry, index) => {
                const rank = index + 1;
                const isCurrentUser = entry.username === currentUser?.username;
                const avatar = getAvatarForUsername(entry.username);

                const rankIcon = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                const rankClass = rank <= 3 ? 'text-2xl' : 'text-lg font-bold text-gray-400';

                const el = document.createElement('div');
                el.className = `p-4 rounded-xl ${isCurrentUser ? 'bg-purple-50 border-2 border-purple-300' : 'bg-gray-50'} ${rank <= 3 ? 'shadow-md' : ''} opacity-0 transform translate-y-4 transition-all duration-300`;

                el.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="${rankClass} w-10 text-center">${rankIcon}</div>
                        <div class="text-2xl">${avatar}</div>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <span class="font-semibold text-gray-800 truncate">${entry.username}</span>
                                ${isCurrentUser ? '<span class="text-xs bg-purple-200 text-purple-700 px-2 py-0.5 rounded-full">YOU</span>' : ''}
                            </div>
                            ${entry.real_name ? `<div class="text-xs text-gray-500">${entry.real_name}</div>` : ''}
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-yellow-600">${entry.weighted_score} pts</div>
                            <div class="text-xs text-gray-500 flex gap-1 justify-end">
                                ${entry.gold > 0 ? `<span>‚≠ê${entry.gold}</span>` : ''}
                                ${entry.silver > 0 ? `<span>ü•à${entry.silver}</span>` : ''}
                                ${entry.bronze > 0 ? `<span>ü•â${entry.bronze}</span>` : ''}
                                ${entry.tin > 0 ? `<span>‚óã${entry.tin}</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;

                this.list.appendChild(el);

                // Staggered animation: each entry fades in with a slight delay
                setTimeout(() => {
                    el.classList.remove('opacity-0', 'translate-y-4');
                    el.classList.add('opacity-100', 'translate-y-0');
                }, index * 50);
            });
        }
    };

    // Global function for WebSocket callback
    function refreshLeaderboard() {
        if (leaderboard.isOpen) {
            leaderboard.refresh();
        }
    }

    // ============== SCENARIO GENERATOR ==============
    class ScenarioGenerator {
        constructor() {
            this.contexts = [
                { topic: "Student Performance", xVar: "hours studied", xUnits: "hours", yVar: "exam score", yUnits: "points", xMin: 0, xMax: 12, yMin: 40, yMax: 100, interceptMeaningful: true, interceptReason: "0 hours of studying is possible" },
                { topic: "Sleep & Grades", xVar: "hours of sleep", xUnits: "hours", yVar: "GPA", yUnits: "points", xMin: 4, xMax: 10, yMin: 1.5, yMax: 4.0, interceptMeaningful: false, interceptReason: "0 hours of sleep is not realistic for students" },
                { topic: "Exercise & Health", xVar: "minutes of exercise per day", xUnits: "minutes", yVar: "resting heart rate", yUnits: "bpm", xMin: 0, xMax: 90, yMin: 50, yMax: 85, interceptMeaningful: true, interceptReason: "0 minutes of exercise is possible" },
                { topic: "Car Value", xVar: "age of car", xUnits: "years", yVar: "resale value", yUnits: "dollars", xMin: 0, xMax: 15, yMin: 2000, yMax: 35000, interceptMeaningful: true, interceptReason: "a new car (0 years) has a value" },
                { topic: "Plant Growth", xVar: "amount of fertilizer", xUnits: "grams", yVar: "plant height", yUnits: "cm", xMin: 0, xMax: 50, yMin: 5, yMax: 45, interceptMeaningful: true, interceptReason: "0 grams of fertilizer is possible" },
                { topic: "Temperature & Sales", xVar: "temperature", xUnits: "¬∞F", yVar: "ice cream sales", yUnits: "dollars", xMin: 50, xMax: 100, yMin: 100, yMax: 800, interceptMeaningful: false, interceptReason: "0¬∞F is outside the realistic range of the data" },
                { topic: "Commute Time", xVar: "distance from work", xUnits: "miles", yVar: "commute time", yUnits: "minutes", xMin: 1, xMax: 40, yMin: 5, yMax: 75, interceptMeaningful: false, interceptReason: "0 miles from work means no commute" },
                { topic: "Social Media", xVar: "hours on social media", xUnits: "hours", yVar: "productivity score", yUnits: "points", xMin: 0, xMax: 8, yMin: 20, yMax: 100, interceptMeaningful: true, interceptReason: "0 hours on social media is possible" },
                { topic: "Coffee & Alertness", xVar: "cups of coffee", xUnits: "cups", yVar: "alertness rating", yUnits: "points (1-10)", xMin: 0, xMax: 6, yMin: 2, yMax: 9, interceptMeaningful: true, interceptReason: "0 cups of coffee is possible" },
                { topic: "Runner Performance", xVar: "age of runner", xUnits: "years", yVar: "marathon time", yUnits: "minutes", xMin: 20, xMax: 70, yMin: 180, yMax: 360, interceptMeaningful: false, interceptReason: "an age of 0 years is not possible for marathon runners" },
                { topic: "Salary & Experience", xVar: "years of experience", xUnits: "years", yVar: "annual salary", yUnits: "thousands of dollars", xMin: 0, xMax: 30, yMin: 35, yMax: 150, interceptMeaningful: true, interceptReason: "0 years of experience (entry level) is possible" },
                { topic: "Tree Growth", xVar: "tree age", xUnits: "years", yVar: "tree height", yUnits: "feet", xMin: 1, xMax: 50, yMin: 3, yMax: 80, interceptMeaningful: false, interceptReason: "a tree cannot be 0 years old" },
                { topic: "Typing Speed", xVar: "months of practice", xUnits: "months", yVar: "typing speed", yUnits: "words per minute", xMin: 0, xMax: 24, yMin: 20, yMax: 90, interceptMeaningful: true, interceptReason: "0 months of practice is possible" },
                { topic: "House Prices", xVar: "square footage", xUnits: "square feet", yVar: "sale price", yUnits: "thousands of dollars", xMin: 800, xMax: 4000, yMin: 100, yMax: 800, interceptMeaningful: false, interceptReason: "a house with 0 square feet doesn't exist" },
                { topic: "Advertising", xVar: "advertising budget", xUnits: "thousands of dollars", yVar: "monthly sales", yUnits: "thousands of dollars", xMin: 0, xMax: 50, yMin: 10, yMax: 200, interceptMeaningful: true, interceptReason: "$0 advertising budget is possible" },
                { topic: "Student Loans", xVar: "years since graduation", xUnits: "years", yVar: "remaining loan balance", yUnits: "thousands of dollars", xMin: 0, xMax: 20, yMin: 0, yMax: 50, interceptMeaningful: true, interceptReason: "0 years (at graduation) is possible" },
                { topic: "Fuel Efficiency", xVar: "vehicle weight", xUnits: "hundreds of pounds", yVar: "fuel efficiency", yUnits: "mpg", xMin: 20, xMax: 60, yMin: 12, yMax: 45, interceptMeaningful: false, interceptReason: "a vehicle with 0 weight is impossible" },
                { topic: "Test Anxiety", xVar: "anxiety level", xUnits: "points (1-10)", yVar: "test performance", yUnits: "percent", xMin: 1, xMax: 10, yMin: 40, yMax: 100, interceptMeaningful: false, interceptReason: "an anxiety level of 0 is outside the measurement scale" },
                { topic: "Restaurant Tips", xVar: "bill amount", xUnits: "dollars", yVar: "tip amount", yUnits: "dollars", xMin: 10, xMax: 150, yMin: 2, yMax: 35, interceptMeaningful: false, interceptReason: "a $0 bill means no meal and no tip" },
                { topic: "Gaming & Grades", xVar: "hours of video games per week", xUnits: "hours", yVar: "GPA", yUnits: "points", xMin: 0, xMax: 40, yMin: 1.5, yMax: 4.0, interceptMeaningful: true, interceptReason: "0 hours of gaming is possible" },
                { topic: "Altitude & Temperature", xVar: "altitude", xUnits: "thousands of feet", yVar: "temperature", yUnits: "¬∞F", xMin: 0, xMax: 15, yMin: 20, yMax: 75, interceptMeaningful: true, interceptReason: "sea level (0 feet) is possible" },
                { topic: "Screen Time & Sleep", xVar: "screen time before bed", xUnits: "minutes", yVar: "sleep quality score", yUnits: "points", xMin: 0, xMax: 180, yMin: 2, yMax: 10, interceptMeaningful: true, interceptReason: "0 minutes of screen time is possible" },
                { topic: "Reading & Vocabulary", xVar: "books read per year", xUnits: "books", yVar: "vocabulary score", yUnits: "points", xMin: 0, xMax: 50, yMin: 200, yMax: 800, interceptMeaningful: true, interceptReason: "reading 0 books is possible" },
                { topic: "Shoe Size & Height", xVar: "shoe size", xUnits: "US size", yVar: "height", yUnits: "inches", xMin: 5, xMax: 14, yMin: 58, yMax: 78, interceptMeaningful: false, interceptReason: "a shoe size of 0 is not realistic" }
            ];
        }

        generate() {
            const context = this.contexts[Math.floor(Math.random() * this.contexts.length)];

            // Generate correlation
            const rSign = Math.random() > 0.5 ? 1 : -1;
            const rMagnitude = 0.3 + Math.random() * 0.65; // 0.3 to 0.95
            const r = Math.round(rSign * rMagnitude * 1000) / 1000;

            // Generate realistic slope and intercept
            const yRange = context.yMax - context.yMin;
            const xRange = context.xMax - context.xMin;

            // Slope magnitude based on ranges and correlation
            const baseSlopeMagnitude = (yRange / xRange) * Math.abs(r);
            const slopeVariation = 0.5 + Math.random(); // 0.5 to 1.5
            const slope = Math.round(rSign * baseSlopeMagnitude * slopeVariation * 100) / 100;

            // Calculate intercept to fit within realistic y range
            const midX = (context.xMin + context.xMax) / 2;
            const midY = (context.yMin + context.yMax) / 2;
            const intercept = Math.round((midY - slope * midX) * 100) / 100;

            // Generate synthetic data points with exact statistics
            const dataPoints = generateSyntheticData(slope, intercept, r, context.xMin, context.xMax, 12);

            return {
                ...context,
                r,
                slope,
                intercept,
                isInterceptMeaningful: context.interceptMeaningful,
                dataPoints
            };
        }
    }

    // ============== GRADER CLASS ==============
    class Grader {
        constructor() {
            this.apiProvider = localStorage.getItem('apiProvider') || 'server';
            this.geminiKey = localStorage.getItem('geminiApiKey') || '';
            this.groqKey = localStorage.getItem('groqApiKey') || '';
            // Server URL - uses the Railway server for AI grading
            this.serverUrl = localStorage.getItem('serverUrl') || 'https://lrsl-driller-production.up.railway.app';
        }

        get apiKey() {
            if (this.apiProvider === 'server') return 'server'; // Server handles keys
            return this.apiProvider === 'gemini' ? this.geminiKey : this.groqKey;
        }

        updateSettings(provider, geminiKey, groqKey) {
            this.apiProvider = provider;
            this.geminiKey = geminiKey;
            this.groqKey = groqKey;
            localStorage.setItem('apiProvider', provider);
            localStorage.setItem('geminiApiKey', geminiKey);
            localStorage.setItem('groqApiKey', groqKey);
        }

        // Call server for AI grading (handles queue and rate limits)
        async callServer(endpoint, data) {
            const response = await fetch(`${this.serverUrl}/api/ai/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || 'Server grading failed');
            }

            return result;
        }

        // Upload API keys to the shared server pool
        async contributeKeysToPool(geminiKey, groqKey) {
            const username = localStorage.getItem('username') || null;

            const promises = [];

            if (geminiKey && geminiKey.startsWith('AIza')) {
                promises.push(
                    fetch(`${this.serverUrl}/api/ai/contribute-key`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ provider: 'gemini', apiKey: geminiKey, username })
                    }).then(r => r.json())
                );
            }

            if (groqKey && groqKey.startsWith('gsk_')) {
                promises.push(
                    fetch(`${this.serverUrl}/api/ai/contribute-key`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ provider: 'groq', apiKey: groqKey, username })
                    }).then(r => r.json())
                );
            }

            if (promises.length > 0) {
                const results = await Promise.all(promises);
                console.log('Keys contributed to pool:', results);
            }
        }

        // Robust JSON extraction that handles malformed AI responses
        extractAndParseJSON(text) {
            // First try direct parsing
            try {
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
            } catch (e) {
                console.log('Direct JSON parse failed, attempting repair...');
            }

            // Try to extract and repair JSON
            try {
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (!jsonMatch) return null;

                let jsonStr = jsonMatch[0];

                // Common fixes for LLM JSON issues:
                // 1. Replace smart quotes with regular quotes
                jsonStr = jsonStr.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");

                // 2. Fix unescaped quotes in string values by finding patterns like "feedback": "...unescaped"quote..."
                // This is a simplified fix - escape quotes that appear mid-string
                jsonStr = jsonStr.replace(/"feedback":\s*"([^}]+?)"/g, (match, content) => {
                    // Escape any unescaped quotes within the feedback content
                    const escaped = content.replace(/(?<!\\)"/g, '\\"');
                    return `"feedback": "${escaped}"`;
                });

                // 3. Remove trailing commas before closing braces
                jsonStr = jsonStr.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');

                // 4. Try parsing again
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('JSON repair failed:', e);

                // Last resort: try to build a valid structure from regex extraction
                try {
                    const slopeMatch = text.match(/"slope":\s*\{\s*"score":\s*"([EPI])"/);
                    const interceptMatch = text.match(/"intercept":\s*\{\s*"score":\s*"([EPI])"/);
                    const correlationMatch = text.match(/"correlation":\s*\{\s*"score":\s*"([EPI])"/);

                    if (slopeMatch && interceptMatch && correlationMatch) {
                        return {
                            slope: { score: slopeMatch[1], feedback: 'AI feedback parsing error - score extracted.' },
                            intercept: { score: interceptMatch[1], feedback: 'AI feedback parsing error - score extracted.' },
                            correlation: { score: correlationMatch[1], feedback: 'AI feedback parsing error - score extracted.' }
                        };
                    }
                } catch (e2) {
                    console.error('Fallback extraction failed:', e2);
                }

                return null;
            }
        }

        async grade(scenario, answers) {
            // Always run keyword grading
            const keywordResult = this.gradeWithRegex(scenario, answers);
            keywordResult._gradingMode = 'regex';

            // Also run AI grading if available
            let aiResult = null;
            if (this.apiProvider !== 'none') {
                try {
                    if (this.apiProvider === 'server') {
                        // Use server-side grading (handles queue + rate limits)
                        aiResult = await this.callServer('grade', { scenario, answers });
                    } else if (this.apiKey) {
                        // Use client-side grading with own API key
                        aiResult = await this.gradeWithAI(scenario, answers);
                    }
                } catch (error) {
                    console.error('AI grading failed:', error);
                    aiResult = { _error: error.message };
                }
            }

            return {
                keyword: keywordResult,
                ai: aiResult,
                // Use AI score if available, otherwise keyword
                slope: aiResult?.slope || keywordResult.slope,
                intercept: aiResult?.intercept || keywordResult.intercept,
                correlation: aiResult?.correlation || keywordResult.correlation,
                _hasAI: !!aiResult && !aiResult._error
            };
        }

        // ============== REGEX GRADING ==============
        gradeWithRegex(scenario, answers) {
            const results = {
                slope: this.gradeSlopeRegex(scenario, answers.slope),
                intercept: this.gradeInterceptRegex(scenario, answers.intercept),
                correlation: this.gradeCorrelationRegex(scenario, answers.correlation)
            };
            return results;
        }

        checkForbiddenWords(text) {
            const forbidden = ['causes', 'cause', 'caused', 'proves', 'prove', 'proven', 'will definitely', 'always will', 'must be'];
            const lower = text.toLowerCase();
            for (const word of forbidden) {
                if (lower.includes(word)) {
                    return { found: true, word };
                }
            }
            return { found: false };
        }

        gradeSlopeRegex(scenario, answer) {
            const lower = answer.toLowerCase();
            const forbidden = this.checkForbiddenWords(answer);

            if (forbidden.found) {
                return {
                    score: 'I',
                    feedback: `Avoid causal language like "${forbidden.word}". Correlation does not imply causation.`
                };
            }

            let points = 0;
            let missing = [];
            let correct = [];

            // Check for prediction language
            const hasPrediction = /predicted|on average|predicts|expect|expected|typically/.test(lower);
            if (hasPrediction) {
                points += 2;
                correct.push('prediction language');
            } else {
                missing.push('Use "predicted" or "on average" to indicate this is an estimate.');
            }

            // Check for correct direction
            const direction = scenario.slope > 0 ? 'positive' : 'negative';
            const increaseWords = /increase|higher|more|greater|goes up|rise/.test(lower);
            const decreaseWords = /decrease|lower|less|fewer|goes down|drop|decline/.test(lower);

            if ((scenario.slope > 0 && increaseWords) || (scenario.slope < 0 && decreaseWords)) {
                points += 2;
                correct.push('correct direction');
            } else if ((scenario.slope > 0 && decreaseWords) || (scenario.slope < 0 && increaseWords)) {
                missing.push(`Direction is wrong. The slope is ${direction} (b = ${scenario.slope}).`);
            } else {
                missing.push('Mention the direction (increase or decrease).');
            }

            // Check for slope value
            const slopeAbs = Math.abs(scenario.slope);
            const hasValue = new RegExp(slopeAbs.toString().replace('.', '\\.?')).test(answer) ||
                            answer.includes(scenario.slope.toString());
            if (hasValue) {
                points += 1;
                correct.push('slope value');
            } else {
                missing.push(`Include the slope value (${Math.abs(scenario.slope)}).`);
            }

            // Check for variable mention
            const hasXVar = lower.includes(scenario.xVar.toLowerCase()) ||
                           lower.includes(scenario.xVar.split(' ')[0].toLowerCase());
            const hasYVar = lower.includes(scenario.yVar.toLowerCase()) ||
                           lower.includes(scenario.yVar.split(' ')[0].toLowerCase());
            if (hasXVar && hasYVar) {
                points += 1;
                correct.push('both variables in context');
            } else {
                if (!hasXVar) missing.push(`Mention the x-variable (${scenario.xVar}).`);
                if (!hasYVar) missing.push(`Mention the y-variable (${scenario.yVar}).`);
            }

            // Check for "1 unit" or similar
            const hasUnit = /for every|for each|per|each additional|one more|1 /.test(lower);
            if (hasUnit) {
                points += 1;
                correct.push('"for every 1 unit" phrasing');
            }

            // Determine score
            let score;
            if (points >= 6) score = 'E';
            else if (points >= 3) score = 'P';
            else score = 'I';

            // Build feedback
            let feedback;
            if (score === 'E') {
                feedback = `Excellent! You included: ${correct.join(', ')}.`;
            } else if (missing.length > 0) {
                feedback = missing.join(' ');
                if (correct.length > 0) {
                    feedback = `Good: ${correct.join(', ')}. Missing: ${missing.join(' ')}`;
                }
            } else {
                feedback = 'Good interpretation!';
            }

            return { score, feedback };
        }

        gradeInterceptRegex(scenario, answer) {
            const lower = answer.toLowerCase();
            const forbidden = this.checkForbiddenWords(answer);

            if (forbidden.found) {
                return {
                    score: 'I',
                    feedback: `Avoid causal language like "${forbidden.word}".`
                };
            }

            let points = 0;
            let missing = [];
            let correct = [];

            // Check if student correctly identifies meaningfulness
            const saysMeaningless = /no meaningful|not meaningful|doesn't make sense|does not make sense|impossible|unrealistic|cannot|can't|outside|no practical/.test(lower);

            if (!scenario.isInterceptMeaningful) {
                // Intercept IS meaningless - student should say so
                if (saysMeaningless) {
                    points += 4;
                    correct.push('correctly identified intercept as meaningless');
                } else {
                    missing.push(`The y-intercept has no meaningful interpretation here because ${scenario.interceptReason}.`);
                }
            }

            // Check for zero mention
            const hasZero = /when.*(?:is |=|equals?).*0|(?:0|zero) (?:hours|minutes|years|cups|books|grams|dollars|feet|miles|points)/.test(lower) ||
                           /x\s*=\s*0|at 0|at zero/.test(lower);
            if (hasZero) {
                points += 1;
                correct.push('referenced x = 0');
            } else if (scenario.isInterceptMeaningful) {
                missing.push('Reference x = 0 in your interpretation.');
            }

            // Check for prediction language
            const hasPrediction = /predicted|on average|predicts|expect|expected|would be/.test(lower);
            if (hasPrediction) {
                points += 1;
                correct.push('prediction language');
            } else if (scenario.isInterceptMeaningful && !saysMeaningless) {
                missing.push('Use "predicted" or "expected" language.');
            }

            // Check for intercept value (if meaningful)
            if (scenario.isInterceptMeaningful) {
                const interceptStr = Math.abs(scenario.intercept).toString();
                const hasValue = answer.includes(scenario.intercept.toString()) ||
                                answer.includes(interceptStr);
                if (hasValue) {
                    points += 1;
                    correct.push('intercept value');
                } else {
                    missing.push(`Include the y-intercept value (${scenario.intercept}).`);
                }
            }

            // Check for variable mention
            const hasYVar = lower.includes(scenario.yVar.toLowerCase()) ||
                           lower.includes(scenario.yVar.split(' ')[0].toLowerCase());
            if (hasYVar) {
                points += 1;
                correct.push('y-variable in context');
            } else if (!saysMeaningless) {
                missing.push(`Mention the y-variable (${scenario.yVar}).`);
            }

            let score;
            if (points >= 5) score = 'E';
            else if (points >= 2) score = 'P';
            else score = 'I';

            // Build feedback
            let feedback;
            if (score === 'E') {
                feedback = `Excellent! You included: ${correct.join(', ')}.`;
            } else if (missing.length > 0) {
                feedback = missing.join(' ');
                if (correct.length > 0) {
                    feedback = `Good: ${correct.join(', ')}. Missing: ${missing.join(' ')}`;
                }
            } else {
                feedback = 'Good interpretation!';
            }

            return { score, feedback };
        }

        gradeCorrelationRegex(scenario, answer) {
            const lower = answer.toLowerCase();
            const forbidden = this.checkForbiddenWords(answer);

            if (forbidden.found) {
                return {
                    score: 'I',
                    feedback: `Avoid causal language like "${forbidden.word}". Correlation does not imply causation.`
                };
            }

            let points = 0;
            let missing = [];
            let correct = [];

            // Check for "linear"
            if (/linear/.test(lower)) {
                points += 2;
                correct.push('"linear"');
            } else {
                missing.push('Include the word "linear".');
            }

            // Check for correct direction
            const isPositive = scenario.r > 0;
            const saysPositive = /positive/.test(lower);
            const saysNegative = /negative/.test(lower);

            if ((isPositive && saysPositive) || (!isPositive && saysNegative)) {
                points += 2;
                correct.push('correct direction');
            } else if ((isPositive && saysNegative) || (!isPositive && saysPositive)) {
                missing.push(`Direction is wrong. r = ${scenario.r} is ${isPositive ? 'positive' : 'negative'}.`);
            } else {
                missing.push('State whether the relationship is positive or negative.');
            }

            // Check for strength
            const absR = Math.abs(scenario.r);
            let correctStrength;
            if (absR < 0.4) correctStrength = 'weak';
            else if (absR < 0.7) correctStrength = 'moderate';
            else correctStrength = 'strong';

            const saysWeak = /weak/.test(lower);
            const saysModerate = /moderate|moderately/.test(lower);
            const saysStrong = /strong/.test(lower);

            if ((correctStrength === 'weak' && saysWeak) ||
                (correctStrength === 'moderate' && saysModerate) ||
                (correctStrength === 'strong' && saysStrong)) {
                points += 2;
                correct.push(`correct strength (${correctStrength})`);
            } else if (saysWeak || saysModerate || saysStrong) {
                missing.push(`Strength assessment: |r| = ${absR.toFixed(2)} suggests a ${correctStrength} relationship.`);
                points += 1; // Partial credit for attempting
            } else {
                missing.push(`Describe the strength (weak, moderate, or strong). |r| = ${absR.toFixed(2)}.`);
            }

            // Check for variable mention
            const hasVars = (lower.includes(scenario.xVar.toLowerCase()) || lower.includes(scenario.xVar.split(' ')[0].toLowerCase())) &&
                           (lower.includes(scenario.yVar.toLowerCase()) || lower.includes(scenario.yVar.split(' ')[0].toLowerCase()));
            if (hasVars) {
                points += 1;
                correct.push('both variables in context');
            } else {
                missing.push('Mention both variables in context.');
            }

            // Check for "relationship" or "association"
            if (/relationship|association|correlation/.test(lower)) {
                points += 1;
                correct.push('"relationship/association"');
            }

            let score;
            if (points >= 7) score = 'E';
            else if (points >= 4) score = 'P';
            else score = 'I';

            // Build feedback
            let feedback;
            if (score === 'E') {
                feedback = `Excellent! You included: ${correct.join(', ')}.`;
            } else if (missing.length > 0) {
                feedback = missing.join(' ');
                if (correct.length > 0) {
                    feedback = `Good: ${correct.join(', ')}. Missing: ${missing.join(' ')}`;
                }
            } else {
                feedback = 'Good interpretation!';
            }

            return { score, feedback };
        }

        // ============== AI GRADING (Direct API Calls) ==============
        // Check if error is a rate limit / quota error
        isRateLimitError(errorMessage) {
            const lower = errorMessage.toLowerCase();
            return lower.includes('quota') || lower.includes('rate limit') ||
                   lower.includes('429') || lower.includes('too many') ||
                   lower.includes('resource exhausted') || lower.includes('limit');
        }

        async gradeWithAI(scenario, answers) {
            const prompt = this.buildPrompt(scenario, answers);
            const primaryProvider = this.apiProvider;
            const fallbackProvider = primaryProvider === 'gemini' ? 'groq' : 'gemini';
            const fallbackKey = fallbackProvider === 'gemini' ? this.geminiKey : this.groqKey;

            // Try primary provider
            try {
                let result;
                if (primaryProvider === 'gemini') {
                    result = await this.callGemini(prompt);
                } else if (primaryProvider === 'groq') {
                    result = await this.callGroq(prompt);
                }

                if (result) {
                    result._gradingMode = 'ai';
                    result._aiProvider = primaryProvider;
                    return result;
                }
                throw new Error('Empty result from AI');
            } catch (primaryError) {
                console.warn(`Primary AI (${primaryProvider}) failed:`, primaryError.message);

                // Try fallback provider if we have a key for it
                if (fallbackKey && (this.isRateLimitError(primaryError.message) || primaryError.message.includes('Invalid'))) {
                    console.log(`Attempting fallback to ${fallbackProvider}...`);
                    try {
                        let result;
                        if (fallbackProvider === 'gemini') {
                            result = await this.callGemini(prompt, this.geminiKey);
                        } else {
                            result = await this.callGroq(prompt, this.groqKey);
                        }

                        if (result) {
                            result._gradingMode = 'ai';
                            result._aiProvider = fallbackProvider;
                            result._wasFallback = true;
                            console.log(`Fallback to ${fallbackProvider} succeeded!`);
                            return result;
                        }
                    } catch (fallbackError) {
                        console.warn(`Fallback AI (${fallbackProvider}) also failed:`, fallbackError.message);
                        // Both failed - return error with details
                        return {
                            _error: `${primaryProvider}: ${primaryError.message}; ${fallbackProvider}: ${fallbackError.message}`,
                            _bothFailed: true
                        };
                    }
                }

                // No fallback available or not a rate limit error
                return { _error: primaryError.message || 'Unknown error' };
            }
        }

        buildPrompt(scenario, answers) {
            const direction = scenario.slope > 0 ? 'increases' : 'decreases';
            const rDirection = scenario.r > 0 ? 'positive' : 'negative';
            const absR = Math.abs(scenario.r);
            const strength = absR < 0.4 ? 'weak' : absR < 0.7 ? 'moderate' : 'strong';

            // Calculate equivalent values for unit conversion acceptance
            const slopeAbs = Math.abs(scenario.slope);
            const interceptAbs = Math.abs(scenario.intercept);

            return `You are an AP Statistics grader. Grade these three LSRL interpretation responses using E/P/I scoring.
BE LENIENT - focus on conceptual understanding, not exact wording.

CONTEXT:
- Topic: ${scenario.topic}
- X variable: ${scenario.xVar} (${scenario.xUnits})
- Y variable: ${scenario.yVar} (${scenario.yUnits})
- Regression equation: ≈∑ = ${scenario.intercept} + ${scenario.slope}x
- Correlation: r = ${scenario.r}
- Y-intercept meaningful: ${scenario.isInterceptMeaningful ? 'Yes' : 'No - ' + scenario.interceptReason}

STUDENT ANSWERS:
1. Slope: "${answers.slope}"
2. Y-intercept: "${answers.intercept}"
3. Correlation: "${answers.correlation}"

CRITICAL - UNIT CONVERSIONS ARE ACCEPTABLE:
- If units are "thousands of dollars", accept BOTH "${slopeAbs} thousands of dollars" AND "${slopeAbs * 1000} dollars"
- Example: "2.29 thousands of dollars" = "2290 dollars" = "$2,290" - ALL ARE CORRECT
- Example: "47.75 thousands of dollars" = "47750 dollars" = "$47,750" - ALL ARE CORRECT
- Similarly for other compound units (hundreds of pounds, etc.)
- The student demonstrates understanding if the VALUE is mathematically equivalent

GRADING RUBRIC:

SLOPE must include:
- "Predicted" or "on average" (MANDATORY)
- Correct direction: "${direction}" (b=${scenario.slope})
- Slope value: ${slopeAbs} (OR equivalent: ${slopeAbs * 1000} if converting from thousands, ${slopeAbs * 100} if converting from hundreds)
- Both variables in context
- "For every 1 [unit]" phrasing
Model answer: "For every increase of 1 ${scenario.xUnits} in ${scenario.xVar}, the predicted ${scenario.yVar} ${direction} by ${slopeAbs} ${scenario.yUnits}, on average."

Y-INTERCEPT:
${scenario.isInterceptMeaningful
    ? `- Reference x=0, use "predicted"/"predicts"/"model predicts", include value ${scenario.intercept} (OR equivalent conversion like ${scenario.intercept * 1000} dollars), name y-variable
Model answer: "When ${scenario.xVar} is 0 ${scenario.xUnits}, the predicted ${scenario.yVar} is ${scenario.intercept} ${scenario.yUnits}."`
    : `- Must state NO meaningful interpretation and explain why (${scenario.interceptReason})
Model answer: "The y-intercept has no meaningful interpretation because ${scenario.interceptReason}."`}

CORRELATION must include:
- Word "linear" (MANDATORY)
- Direction: "${rDirection}"
- Strength: "${strength}" (|r|=${absR.toFixed(2)})
- Both variables
- "relationship" or "association"
Model answer: "There is a ${strength}, ${rDirection}, linear relationship between ${scenario.xVar} and ${scenario.yVar}."

AUTOMATIC FAILURES: "causes", "proves" = Incorrect

Respond with ONLY this JSON (no other text):
{
  "slope": {"score": "E", "feedback": "Excellent! You included: [list correct elements]."},
  "intercept": {"score": "P", "feedback": "Good: [correct]. Missing: [missing]."},
  "correlation": {"score": "I", "feedback": "[What's wrong and how to fix]."}
}

Score meanings: E=Essentially Correct (all key elements), P=Partially Correct (some elements), I=Incorrect (major errors/missing mandatory elements)
BE GENEROUS - if the student shows understanding with equivalent unit conversions, give credit!
For E: list what they got right. For P: list good AND missing. For I: explain error and fix.`;
        }

        async callGemini(prompt, apiKey = null) {
            const key = apiKey || this.geminiKey;
            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${key}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 1500
                        }
                    })
                }
            );

            const data = await response.json();

            if (data.error) {
                throw new Error(`Gemini: ${data.error.message}`);
            }

            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error('Gemini: Empty response');
            }

            const text = data.candidates[0].content.parts[0].text;
            console.log('Gemini response:', text);

            // Extract JSON from response using robust parser
            const parsed = this.extractAndParseJSON(text);
            if (parsed && parsed.slope && parsed.intercept && parsed.correlation) {
                return parsed;
            }
            throw new Error('Gemini: Invalid response structure');
        }

        async callGroq(prompt, apiKey = null) {
            const key = apiKey || this.groqKey;
            const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify({
                    model: 'llama-3.3-70b-versatile',
                    messages: [
                        { role: 'system', content: 'You are an AP Statistics grader. Always respond with valid JSON only.' },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.1,
                    max_tokens: 1500
                })
            });

            const data = await response.json();

            if (data.error) {
                throw new Error(`Groq: ${data.error.message}`);
            }

            if (!data.choices?.[0]?.message?.content) {
                throw new Error('Groq: Empty response');
            }

            const text = data.choices[0].message.content;
            console.log('Groq response:', text);

            // Extract JSON from response using robust parser
            const parsed = this.extractAndParseJSON(text);
            if (parsed && parsed.slope && parsed.intercept && parsed.correlation) {
                return parsed;
            }
            throw new Error('Groq: Invalid response structure');
        }

        // ============== PARAGRAPH MODE GRADING ==============
        async gradeParagraph(scenario, paragraph) {
            // Run keyword grading on the full paragraph for each component
            const keywordResult = {
                slope: this.gradeSlopeRegex(scenario, paragraph),
                intercept: this.gradeInterceptRegex(scenario, paragraph),
                correlation: this.gradeCorrelationRegex(scenario, paragraph),
                _gradingMode: 'regex'
            };

            // Also run AI grading if available
            let aiResult = null;
            if (this.apiProvider !== 'none') {
                try {
                    if (this.apiProvider === 'server') {
                        // Use server-side grading (handles queue + rate limits)
                        aiResult = await this.callServer('grade-paragraph', { scenario, paragraph });
                    } else if (this.apiKey) {
                        // Use client-side grading with own API key
                        aiResult = await this.gradeParagraphWithAI(scenario, paragraph);
                    }
                } catch (error) {
                    console.error('AI paragraph grading failed:', error);
                    aiResult = { _error: error.message };
                }
            }

            return {
                keyword: keywordResult,
                ai: aiResult,
                _hasAI: !!aiResult && !aiResult._error
            };
        }

        async gradeParagraphWithAI(scenario, paragraph) {
            const prompt = this.buildParagraphPrompt(scenario, paragraph);
            const primaryProvider = this.apiProvider;
            const fallbackProvider = primaryProvider === 'gemini' ? 'groq' : 'gemini';
            const fallbackKey = fallbackProvider === 'gemini' ? this.geminiKey : this.groqKey;

            // Try primary provider
            try {
                let result;
                if (primaryProvider === 'gemini') {
                    result = await this.callGemini(prompt);
                } else if (primaryProvider === 'groq') {
                    result = await this.callGroq(prompt);
                }

                if (result) {
                    result._gradingMode = 'ai';
                    result._aiProvider = primaryProvider;
                    return result;
                }
                throw new Error('Empty result from AI');
            } catch (primaryError) {
                console.warn(`Primary AI (${primaryProvider}) failed for paragraph:`, primaryError.message);

                // Try fallback provider if we have a key for it
                if (fallbackKey && (this.isRateLimitError(primaryError.message) || primaryError.message.includes('Invalid'))) {
                    console.log(`Attempting paragraph fallback to ${fallbackProvider}...`);
                    try {
                        let result;
                        if (fallbackProvider === 'gemini') {
                            result = await this.callGemini(prompt, this.geminiKey);
                        } else {
                            result = await this.callGroq(prompt, this.groqKey);
                        }

                        if (result) {
                            result._gradingMode = 'ai';
                            result._aiProvider = fallbackProvider;
                            result._wasFallback = true;
                            console.log(`Paragraph fallback to ${fallbackProvider} succeeded!`);
                            return result;
                        }
                    } catch (fallbackError) {
                        console.warn(`Fallback AI (${fallbackProvider}) also failed for paragraph:`, fallbackError.message);
                        // Both failed - return error with details
                        return {
                            _error: `${primaryProvider}: ${primaryError.message}; ${fallbackProvider}: ${fallbackError.message}`,
                            _bothFailed: true
                        };
                    }
                }

                // No fallback available or not a rate limit error
                return { _error: primaryError.message || 'Unknown error' };
            }
        }

        buildParagraphPrompt(scenario, paragraph) {
            const direction = scenario.slope > 0 ? 'increases' : 'decreases';
            const rDirection = scenario.r > 0 ? 'positive' : 'negative';
            const absR = Math.abs(scenario.r);
            const strength = absR < 0.4 ? 'weak' : absR < 0.7 ? 'moderate' : 'strong';
            const slopeAbs = Math.abs(scenario.slope);

            return `You are an AP Statistics grader. Grade this SINGLE PARAGRAPH that should contain interpretations for slope, y-intercept, and correlation.
BE LENIENT - focus on conceptual understanding, not exact wording.

CONTEXT:
- Topic: ${scenario.topic}
- X variable: ${scenario.xVar} (${scenario.xUnits})
- Y variable: ${scenario.yVar} (${scenario.yUnits})
- Regression equation: ≈∑ = ${scenario.intercept} + ${scenario.slope}x
- Correlation: r = ${scenario.r}
- Y-intercept meaningful: ${scenario.isInterceptMeaningful ? 'Yes' : 'No - ' + scenario.interceptReason}

STUDENT'S PARAGRAPH:
"${paragraph}"

YOUR TASK:
1. Identify the three components in the paragraph: slope interpretation, y-intercept interpretation, and correlation interpretation
2. Grade each component using E/P/I scoring based on these rubrics:

SLOPE must include:
- "Predicted" or "on average" (MANDATORY)
- Correct direction: "${direction}"
- Slope value: ${slopeAbs}
- Both variables in context
- "For every 1 [unit]" phrasing

Y-INTERCEPT:
${scenario.isInterceptMeaningful
    ? `- Reference x=0, use "predicted"/"predicts", include value ${scenario.intercept}, name y-variable`
    : `- Must state NO meaningful interpretation and explain why (${scenario.interceptReason})`}

CORRELATION must include:
- Word "linear" (MANDATORY)
- Direction: "${rDirection}"
- Strength: "${strength}" (|r|=${absR.toFixed(2)})
- Both variables
- "relationship" or "association"

AUTOMATIC FAILURES: "causes", "proves" = Incorrect

Respond with ONLY this JSON (no other text):
{
  "slope": {"score": "E", "feedback": "..."},
  "intercept": {"score": "P", "feedback": "..."},
  "correlation": {"score": "I", "feedback": "..."}
}

Score meanings: E=Essentially Correct (all key elements), P=Partially Correct (some elements), I=Incorrect (major errors/missing)`;
        }
    }

    // ============== EXACT SYNTHETIC DATA GENERATOR ==============
    // Generate data with EXACT target statistics using orthogonal z-score construction
    function generateSyntheticData(slope, intercept, r, xMin, xMax, numPoints = 12) {
        // Helper: Box-Muller transform for normally distributed random numbers
        function randomNormal() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        // Helper: Standardize array to exact mean=0, sample variance=1
        function standardize(arr) {
            const n = arr.length;
            const mean = arr.reduce((a, b) => a + b, 0) / n;
            let centered = arr.map(v => v - mean);
            const variance = centered.reduce((a, b) => a + b * b, 0) / (n - 1);
            const std = Math.sqrt(variance);
            return centered.map(v => v / std);
        }

        // Step 1: Generate and standardize z-scores for x
        let zx = Array.from({ length: numPoints }, () => randomNormal());
        zx = standardize(zx);

        // Step 2: Generate and standardize independent errors
        let e = Array.from({ length: numPoints }, () => randomNormal());
        e = standardize(e);

        // Step 3: Make e orthogonal to zx using Gram-Schmidt
        const dotEZx = e.reduce((sum, ei, i) => sum + ei * zx[i], 0);
        const dotZxZx = zx.reduce((sum, zxi) => sum + zxi * zxi, 0);
        e = e.map((ei, i) => ei - (dotEZx / dotZxZx) * zx[i]);

        // Re-standardize e after orthogonalization
        e = standardize(e);

        // Step 4: Construct zy with EXACT correlation r
        const sqrtOneMinusR2 = Math.sqrt(Math.max(0, 1 - r * r));
        let zy = zx.map((zxi, i) => r * zxi + sqrtOneMinusR2 * e[i]);

        // Step 5: Transform z-scores to raw scores
        const xBar = (xMin + xMax) / 2;
        const sx = (xMax - xMin) / 5;
        const sy = r !== 0 ? Math.abs(slope * sx / r) : sx;
        const yBar = intercept + slope * xBar;

        // Transform to raw coordinates
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            points.push({
                x: Math.round((xBar + sx * zx[i]) * 10) / 10,
                y: Math.round((yBar + sy * zy[i]) * 10) / 10
            });
        }

        return points;
    }

    // ============== SVG SCATTERPLOT GENERATOR ==============
    function generateScatterplotSVG(dataPoints, slope, intercept, xMin, xMax, yMin, yMax) {
        const width = 120;
        const height = 80;
        const padding = 10;

        // Calculate actual min/max from data for proper scaling
        const actualXMin = Math.min(...dataPoints.map(p => p.x));
        const actualXMax = Math.max(...dataPoints.map(p => p.x));
        const actualYMin = Math.min(...dataPoints.map(p => p.y));
        const actualYMax = Math.max(...dataPoints.map(p => p.y));

        // Scale factors
        const xScale = (width - 2 * padding) / (actualXMax - actualXMin);
        const yScale = (height - 2 * padding) / (actualYMax - actualYMin);

        // Create SVG
        let svg = `<svg width="${width}" height="${height}" class="bg-gray-50 rounded-lg">`;

        // Draw points (transform data coordinates to SVG coordinates)
        dataPoints.forEach(p => {
            const svgX = padding + (p.x - actualXMin) * xScale;
            const svgY = height - padding - (p.y - actualYMin) * yScale; // Flip Y axis
            svg += `<circle cx="${svgX}" cy="${svgY}" r="3" fill="#6366f1" opacity="0.7"/>`;
        });

        // Draw LSRL line
        const lineX1 = actualXMin;
        const lineX2 = actualXMax;
        const lineY1 = intercept + slope * lineX1;
        const lineY2 = intercept + slope * lineX2;

        const svgX1 = padding + (lineX1 - actualXMin) * xScale;
        const svgX2 = padding + (lineX2 - actualXMin) * xScale;
        const svgY1 = height - padding - (lineY1 - actualYMin) * yScale;
        const svgY2 = height - padding - (lineY2 - actualYMin) * yScale;

        svg += `<line x1="${svgX1}" y1="${svgY1}" x2="${svgX2}" y2="${svgY2}" stroke="#a855f7" stroke-width="2" stroke-dasharray="4"/>`;

        svg += '</svg>';
        return svg;
    }

    // ============== APP STATE & INITIALIZATION ==============
    let currentScenario = null;
    const generator = new ScenarioGenerator();
    const grader = new Grader();

    // Track which hints have been opened for current scenario
    let hintsOpenedThisScenario = new Set();

    // Load streaks and stars from localStorage
    let streaks = JSON.parse(localStorage.getItem('lsrlStreaks')) || {
        slope: 0, intercept: 0, correlation: 0
    };

    // Stars by type: gold (0 hints), silver (1 hint), bronze (2 hints), tin (3 hints)
    let starCounts = JSON.parse(localStorage.getItem('lsrlStarCounts')) || {
        gold: 0, silver: 0, bronze: 0, tin: 0
    };

    // Tier 2 (Paragraph Mode) state
    let starCountsTier2 = JSON.parse(localStorage.getItem('lsrlStarCountsTier2')) || {
        gold: 0, silver: 0, bronze: 0, tin: 0
    };
    let paragraphStreak = parseInt(localStorage.getItem('lsrlParagraphStreak')) || 0;
    let currentMode = '3-part'; // '3-part' or 'paragraph'
    let paragraphModeUnlocked = false; // derived from starCounts.gold >= 7

    function updateStreakDisplay() {
        document.getElementById('slope-streak').textContent = streaks.slope;
        document.getElementById('intercept-streak').textContent = streaks.intercept;
        document.getElementById('correlation-streak').textContent = streaks.correlation;
        document.getElementById('paragraph-streak').textContent = paragraphStreak;

        // Update star counts (Tier 1)
        document.getElementById('gold-count').textContent = starCounts.gold;
        document.getElementById('silver-count').textContent = starCounts.silver;
        document.getElementById('bronze-count').textContent = starCounts.bronze;
        document.getElementById('tin-count').textContent = starCounts.tin;

        // Update star counts (Tier 2)
        document.getElementById('gold-count-t2').textContent = starCountsTier2.gold;
        document.getElementById('silver-count-t2').textContent = starCountsTier2.silver;
        document.getElementById('bronze-count-t2').textContent = starCountsTier2.bronze;
        document.getElementById('tin-count-t2').textContent = starCountsTier2.tin;

        // Update rank display
        updateRankDisplay();
    }

    function updateRankDisplay() {
        const rank = getCurrentRank(starCounts);
        const nextRank = getNextRank(starCounts);
        const progress = getRankProgress(starCounts);
        const score = getWeightedScore(starCounts);

        document.getElementById('rank-icon').textContent = rank.icon;
        document.getElementById('rank-name').textContent = rank.name;
        document.getElementById('rank-points').textContent = `${score} pts`;
        document.getElementById('rank-progress-bar').style.width = `${progress}%`;

        // Color the progress bar based on rank
        const colorMap = {
            gray: 'bg-gray-400',
            green: 'bg-green-500',
            blue: 'bg-blue-500',
            purple: 'bg-purple-500',
            orange: 'bg-orange-500',
            yellow: 'bg-yellow-500',
            red: 'bg-red-500'
        };
        const progressBar = document.getElementById('rank-progress-bar');
        progressBar.className = `h-full ${colorMap[rank.color] || 'bg-purple-500'} transition-all duration-500`;

        // Update rank display tooltip
        const rankDisplay = document.getElementById('rank-display');
        if (nextRank) {
            rankDisplay.title = `${score}/${nextRank.minPoints} points to ${nextRank.name}`;
        } else {
            rankDisplay.title = 'Maximum rank achieved!';
        }
    }

    // Show teacher-specific controls
    function showTeacherControls() {
        document.getElementById('class-time-btn').classList.remove('hidden');
        console.log('Teacher mode activated');
    }

    // ============== CLASS TIME CONTROLLER ==============
    const classTime = {
        active: false,
        startTime: null,
        timerInterval: null,
        starsEarned: 0,
        goalTarget: 3, // Default goal (gold stars = all correct, no hints)

        start() {
            this.active = true;
            this.startTime = Date.now();
            this.starsEarned = 0;

            // Show banner
            document.getElementById('class-time-banner').classList.remove('hidden');
            document.getElementById('end-class-time-btn').classList.toggle('hidden', !isTeacherMode);
            document.getElementById('class-time-btn').innerHTML = '<span class="text-lg">‚è∏Ô∏è</span><span class="text-sm font-medium">Active</span>';
            document.getElementById('class-time-btn').classList.remove('from-green-500', 'to-emerald-500');
            document.getElementById('class-time-btn').classList.add('from-yellow-500', 'to-orange-500');

            // Reset goal display
            document.getElementById('class-stars-earned').textContent = '0';
            document.getElementById('class-goal-target').textContent = this.goalTarget;
            document.getElementById('class-goal-bar').style.width = '0%';

            // Update sticky position
            document.querySelector('.scenario-sticky').style.top = '108px';

            // Start timer
            this.updateTimer();
            this.timerInterval = setInterval(() => this.updateTimer(), 1000);

            // Play sound
            soundEngine.init();
            soundEngine.classTimeStart();

            // Broadcast to others via WebSocket
            if (railwayClient.connected) {
                railwayClient.send({ type: 'class_time_start', goal: this.goalTarget });
            }
        },

        end() {
            this.active = false;
            clearInterval(this.timerInterval);

            const goalReached = this.starsEarned >= this.goalTarget;

            // Hide banner
            document.getElementById('class-time-banner').classList.add('hidden');
            document.getElementById('class-time-btn').innerHTML = '<span class="text-lg">üîî</span><span class="text-sm font-medium">Class Time</span>';
            document.getElementById('class-time-btn').classList.add('from-green-500', 'to-emerald-500');
            document.getElementById('class-time-btn').classList.remove('from-yellow-500', 'to-orange-500');

            // Reset sticky position
            document.querySelector('.scenario-sticky').style.top = '60px';

            // Show summary notification
            if (goalReached) {
                showClassGoalReached();
            }

            // Broadcast end
            if (railwayClient.connected) {
                railwayClient.send({ type: 'class_time_end', stars: this.starsEarned, goalReached });
            }
        },

        updateTimer() {
            const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('class-time-timer').textContent = `${mins}:${secs}`;
        },

        addStar() {
            if (this.active) {
                this.starsEarned++;
                document.getElementById('class-stars-earned').textContent = this.starsEarned;

                // Update progress bar
                const progress = Math.min(100, (this.starsEarned / this.goalTarget) * 100);
                document.getElementById('class-goal-bar').style.width = `${progress}%`;

                // Check if goal reached
                if (this.starsEarned === this.goalTarget) {
                    // Goal reached! Celebrate!
                    document.getElementById('class-goal-bar').classList.add('animate-pulse');
                    soundEngine.init();
                    soundEngine.rankUp();
                }
            }
        },

        setGoal(target) {
            this.goalTarget = target;
            document.getElementById('class-goal-target').textContent = target;
        }
    };

    // Class goal reached celebration
    function showClassGoalReached() {
        const toast = document.createElement('div');
        toast.className = 'fixed top-1/3 left-1/2 -translate-x-1/2 bg-gradient-to-r from-yellow-400 to-orange-500 text-white rounded-2xl shadow-2xl p-8 z-50 text-center pointer-events-none';
        toast.innerHTML = `
            <div class="text-6xl mb-4">üéâ</div>
            <div class="text-2xl font-bold mb-2">CLASS GOAL REACHED!</div>
            <div class="text-lg opacity-90">${classTime.starsEarned} stars earned together!</div>
        `;

        document.body.appendChild(toast);
        celebrate(); // Confetti!

        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translate(-50%, -20px)';
            toast.style.transition = 'all 0.5s ease-out';
            setTimeout(() => toast.remove(), 500);
        }, 5000);
    }

    // Update sound toggle UI
    function updateSoundToggleUI() {
        const toggle = document.getElementById('sound-toggle');
        const dot = document.getElementById('sound-toggle-dot');
        const label = toggle.nextElementSibling;

        if (soundEngine.enabled) {
            toggle.className = 'relative inline-flex h-6 w-11 items-center rounded-full bg-purple-600 transition-colors';
            dot.className = 'inline-block h-4 w-4 transform rounded-full bg-white shadow transition-transform translate-x-6';
            if (label) label.textContent = 'Sound effects enabled';
        } else {
            toggle.className = 'relative inline-flex h-6 w-11 items-center rounded-full bg-gray-300 transition-colors';
            dot.className = 'inline-block h-4 w-4 transform rounded-full bg-white shadow transition-transform translate-x-1';
            if (label) label.textContent = 'Sound effects disabled';
        }
    }

    // Show rank up notification
    function showRankUpNotification(oldRank, newRank) {
        const toast = document.createElement('div');
        toast.className = 'fixed top-1/3 left-1/2 -translate-x-1/2 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-2xl shadow-2xl p-6 z-50 animate-slide-in text-center pointer-events-none';
        toast.innerHTML = `
            <div class="text-5xl mb-3">${newRank.icon}</div>
            <div class="text-xl font-bold mb-1">Rank Up!</div>
            <div class="text-purple-100">${oldRank.name} ‚Üí ${newRank.name}</div>
        `;

        document.body.appendChild(toast);

        // Add celebration effect
        toast.style.animation = 'pulse 0.5s ease-in-out 3';

        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translate(-50%, -20px)';
            toast.style.transition = 'all 0.5s ease-out';
            setTimeout(() => toast.remove(), 500);
        }, 3000);
    }

    function saveStreaks() {
        localStorage.setItem('lsrlStreaks', JSON.stringify(streaks));
        localStorage.setItem('lsrlStarCounts', JSON.stringify(starCounts));
        localStorage.setItem('lsrlStarCountsTier2', JSON.stringify(starCountsTier2));
        localStorage.setItem('lsrlParagraphStreak', paragraphStreak);

        // Also save to IndexedDB for better persistence
        db.meta.put({ key: 'streaks', value: streaks }).catch(e => console.warn('Dexie streaks save failed:', e));
        db.meta.put({ key: 'stars', value: starCounts }).catch(e => console.warn('Dexie stars save failed:', e));
        db.meta.put({ key: 'starsTier2', value: starCountsTier2 }).catch(e => console.warn('Dexie tier2 stars save failed:', e));
        db.meta.put({ key: 'paragraphStreak', value: paragraphStreak }).catch(e => console.warn('Dexie paragraph streak save failed:', e));
    }

    // Save progress record to IndexedDB and cloud (called after grading)
    async function saveProgressRecord(scenario, results, allCorrect, hintsUsed, starType) {
        try {
            const identity = await dbHelpers.getIdentity();
            const username = identity?.username || 'anonymous';

            // Determine best scores
            const scoreOrder = { 'E': 3, 'P': 2, 'I': 1 };
            const getBestScore = (type) => {
                const kw = results.keyword[type]?.score || 'I';
                const ai = results.ai?.[type]?.score;
                if (ai && scoreOrder[ai] > scoreOrder[kw]) return ai;
                return kw;
            };

            const progressData = {
                username,
                scenario_topic: scenario.topic,
                slope_score: getBestScore('slope'),
                intercept_score: getBestScore('intercept'),
                correlation_score: getBestScore('correlation'),
                hints_used: hintsUsed,
                star_type: starType,
                all_correct: allCorrect,
                grading_mode: results._hasAI ? 'both' : 'keywords',
                ai_provider: results.ai?._aiProvider || null
            };

            // Save locally
            await dbHelpers.saveProgress(progressData);
            console.log('Progress saved to IndexedDB:', progressData);

            // Sync to cloud if connected
            if (RAILWAY_URL) {
                railwayClient.saveProgress(progressData);

                // Notify others of star earned via WebSocket
                if (starType) {
                    railwayClient.notifyStarEarned(username, starType, scenario.topic);
                }
            }
        } catch (err) {
            console.error('Failed to save progress:', err);
        }
    }

    function updateHintStatus() {
        const hintsUsed = hintsOpenedThisScenario.size;
        const starEl = document.getElementById('hint-status').querySelector('span:first-child');
        const labelEl = document.getElementById('potential-star');

        if (hintsUsed === 0) {
            starEl.className = 'text-yellow-400';
            labelEl.textContent = 'Gold';
            labelEl.className = 'text-yellow-600 font-medium';
        } else if (hintsUsed === 1) {
            starEl.className = 'text-gray-400';
            labelEl.textContent = 'Silver';
            labelEl.className = 'text-gray-500 font-medium';
        } else if (hintsUsed === 2) {
            starEl.className = 'text-amber-600';
            labelEl.textContent = 'Bronze';
            labelEl.className = 'text-amber-700 font-medium';
        } else {
            starEl.className = 'text-stone-400';
            labelEl.textContent = 'Tin';
            labelEl.className = 'text-stone-500 font-medium';
        }
    }

    function celebrate() {
        // Screen flash
        document.body.classList.add('screen-flash');
        setTimeout(() => document.body.classList.remove('screen-flash'), 500);

        // Confetti
        const colors = ['#a855f7', '#3b82f6', '#22c55e', '#eab308', '#ef4444', '#ec4899'];
        const confettiCount = 50;

        for (let i = 0; i < confettiCount; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + 'vw';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
            confetti.style.width = (Math.random() * 10 + 5) + 'px';
            confetti.style.height = (Math.random() * 10 + 5) + 'px';
            confetti.style.animation = `confetti-fall ${Math.random() * 2 + 2}s linear forwards`;
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            document.body.appendChild(confetti);

            // Remove confetti after animation
            setTimeout(() => confetti.remove(), 4000);
        }
    }

    // ============== PARAGRAPH MODE FUNCTIONS ==============
    function checkParagraphModeUnlock() {
        const wasUnlocked = paragraphModeUnlocked;
        paragraphModeUnlocked = starCounts.gold >= 7;

        if (paragraphModeUnlocked) {
            document.getElementById('mode-tabs').classList.remove('hidden');
            document.getElementById('tier2-stars').classList.remove('hidden');

            // First-time unlock celebration
            if (!wasUnlocked && !localStorage.getItem('paragraphModeUnlockShown')) {
                showParagraphUnlockCelebration();
                localStorage.setItem('paragraphModeUnlockShown', 'true');
            }
        }
    }

    function showParagraphUnlockCelebration() {
        const toast = document.createElement('div');
        toast.className = 'fixed top-1/3 left-1/2 -translate-x-1/2 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-2xl shadow-2xl p-6 z-50 text-center pointer-events-none';
        toast.innerHTML = `
            <div class="text-5xl mb-3">üéì</div>
            <div class="text-xl font-bold mb-1">Paragraph Mode Unlocked!</div>
            <div class="text-purple-100">You've earned 7 gold stars. Try writing full conclusions!</div>
        `;
        document.body.appendChild(toast);
        celebrate();
        soundEngine.init();
        soundEngine.rankUp();

        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'all 0.5s ease-out';
            setTimeout(() => toast.remove(), 500);
        }, 4000);
    }

    function setMode(mode) {
        currentMode = mode;
        const is3Part = mode === '3-part';

        // Toggle input sections
        document.getElementById('three-part-section').classList.toggle('hidden', !is3Part);
        document.getElementById('paragraph-section').classList.toggle('hidden', is3Part);

        // Toggle streak displays (show 3-part streaks or paragraph streak)
        document.querySelectorAll('.streak-3part').forEach(el => el.classList.toggle('hidden', !is3Part));
        document.getElementById('paragraph-streak-display').classList.toggle('hidden', is3Part);

        // Update tab styling
        const tab3Part = document.getElementById('mode-3part');
        const tabParagraph = document.getElementById('mode-paragraph');

        if (is3Part) {
            tab3Part.classList.add('bg-white', 'shadow', 'text-purple-700');
            tab3Part.classList.remove('text-gray-600');
            tabParagraph.classList.remove('bg-white', 'shadow', 'text-purple-700');
            tabParagraph.classList.add('text-gray-600');
        } else {
            tabParagraph.classList.add('bg-white', 'shadow', 'text-purple-700');
            tabParagraph.classList.remove('text-gray-600');
            tab3Part.classList.remove('bg-white', 'shadow', 'text-purple-700');
            tab3Part.classList.add('text-gray-600');
        }

        // Reset hint tracking for mode switch
        hintsOpenedThisScenario = new Set();
        updateHintStatus();

        // Clear paragraph input when switching modes
        if (!is3Part) {
            document.getElementById('paragraph-input').value = '';
            const feedbackEl = document.getElementById('paragraph-feedback');
            feedbackEl.classList.add('hidden');
            feedbackEl.innerHTML = '';
            document.getElementById('paragraph-card').className = 'bg-white rounded-xl shadow-lg p-5 feedback-card';
        }
    }

    function formatAIError(errorText) {
        const lower = errorText.toLowerCase();

        // Quota/rate limit errors
        if (lower.includes('quota') || lower.includes('rate limit') || lower.includes('429')) {
            return {
                title: 'Rate Limit Reached',
                message: 'You\'ve used up your free API quota. Try again later, switch to a different AI provider in Settings, or continue with Keywords-only grading.'
            };
        }

        // Invalid API key
        if (lower.includes('api key not valid') || lower.includes('invalid api key') || lower.includes('unauthorized') || lower.includes('401')) {
            return {
                title: 'Invalid API Key',
                message: 'Your API key isn\'t working. Check Settings to make sure you\'ve entered the correct key for the selected provider.'
            };
        }

        // Wrong key for provider (e.g., Groq key used with Gemini)
        if (lower.includes('gsk_') && lower.includes('gemini')) {
            return {
                title: 'Wrong API Key Type',
                message: 'You\'re using a Groq key with Gemini. Gemini keys start with "AIza..." - check your Settings.'
            };
        }

        // Network errors
        if (lower.includes('network') || lower.includes('fetch') || lower.includes('failed to fetch')) {
            return {
                title: 'Connection Error',
                message: 'Couldn\'t reach the AI service. Check your internet connection and try again.'
            };
        }

        // Empty/invalid response
        if (lower.includes('empty') || lower.includes('no json') || lower.includes('invalid response')) {
            return {
                title: 'AI Response Error',
                message: 'The AI returned an unexpected response. Try grading again.'
            };
        }

        // Default fallback
        return {
            title: 'AI Grading Failed',
            message: errorText.length > 100 ? errorText.substring(0, 100) + '...' : errorText
        };
    }

    function updateModeToggleUI() {
        const toggle = document.getElementById('ai-toggle');
        const toggleDot = document.getElementById('ai-toggle-dot');
        const useAI = grader.apiProvider !== 'none' && grader.apiKey;

        if (useAI) {
            toggle.className = 'relative inline-flex h-5 w-9 items-center rounded-full transition-colors bg-purple-600';
            toggleDot.className = 'inline-block h-3.5 w-3.5 transform rounded-full bg-white shadow transition-transform translate-x-4';
        } else {
            toggle.className = 'relative inline-flex h-5 w-9 items-center rounded-full transition-colors bg-gray-300';
            toggleDot.className = 'inline-block h-3.5 w-3.5 transform rounded-full bg-white shadow transition-transform translate-x-1';
        }

        // Update status text
        const statusEl = document.getElementById('grading-status');
        if (grader.apiProvider !== 'none' && !grader.apiKey) {
            statusEl.textContent = '(no key)';
            statusEl.className = 'text-xs text-orange-500 ml-1';
        } else if (useAI) {
            const provider = grader.apiProvider === 'gemini' ? 'Gemini' : 'Groq';
            statusEl.textContent = `(${provider})`;
            statusEl.className = 'text-xs text-purple-500 ml-1';
        } else {
            statusEl.textContent = '(off)';
            statusEl.className = 'text-xs text-gray-400 ml-1';
        }
    }

    function loadScenario() {
        currentScenario = generator.generate();

        // Reset hint tracking for new scenario
        hintsOpenedThisScenario = new Set();

        // Close any open hints
        document.querySelectorAll('.hint-text').forEach(hint => {
            hint.classList.remove('show');
        });

        // Reset hint status indicator
        updateHintStatus();

        // Update UI
        document.getElementById('scenario-title').textContent = currentScenario.topic;
        document.getElementById('equation-display').textContent =
            `${currentScenario.intercept} + ${currentScenario.slope}x`;
        document.getElementById('correlation-display').textContent =
            currentScenario.r;
        document.getElementById('context-details').innerHTML =
            `<strong>x:</strong> ${currentScenario.xVar} (${currentScenario.xUnits}) | <strong>y:</strong> ${currentScenario.yVar} (${currentScenario.yUnits})`;

        // Generate scatterplot using the actual data points
        document.getElementById('scatterplot-container').innerHTML =
            generateScatterplotSVG(currentScenario.dataPoints, currentScenario.slope, currentScenario.intercept,
                currentScenario.xMin, currentScenario.xMax, currentScenario.yMin, currentScenario.yMax);

        // Clear inputs and feedback
        document.getElementById('slope-input').value = '';
        document.getElementById('intercept-input').value = '';
        document.getElementById('correlation-input').value = '';
        document.getElementById('paragraph-input').value = '';

        ['slope', 'intercept', 'correlation'].forEach(type => {
            const feedbackEl = document.getElementById(`${type}-feedback`);
            feedbackEl.classList.add('hidden');
            feedbackEl.innerHTML = '';
            document.getElementById(`${type}-card`).className = 'bg-white rounded-xl shadow-lg p-5 feedback-card';
        });

        // Also clear paragraph feedback
        const paragraphFeedback = document.getElementById('paragraph-feedback');
        paragraphFeedback.classList.add('hidden');
        paragraphFeedback.innerHTML = '';
        document.getElementById('paragraph-card').className = 'bg-white rounded-xl shadow-lg p-5 feedback-card';

        // Show grade button, hide other buttons
        showButton('grade-btn', true);
        showButton('try-again-btn', false);
        showButton('next-btn', false);

        // Update grading mode toggle
        updateModeToggleUI();
    }

    function showButton(id, visible) {
        const btn = document.getElementById(id);
        if (visible) {
            btn.style.display = 'inline-flex';
        } else {
            btn.style.display = 'none';
        }
    }

    function openExplorer() {
        if (!currentScenario) return;

        const params = new URLSearchParams({
            topic: currentScenario.topic,
            xVar: currentScenario.xVar,
            yVar: currentScenario.yVar,
            xUnits: currentScenario.xUnits,
            yUnits: currentScenario.yUnits,
            slope: currentScenario.slope,
            intercept: currentScenario.intercept,
            r: currentScenario.r,
            xMin: currentScenario.xMin,
            xMax: currentScenario.xMax,
            yMin: currentScenario.yMin,
            yMax: currentScenario.yMax,
            // Pass actual data points as JSON
            data: JSON.stringify(currentScenario.dataPoints)
        });
        window.open(`zscore_3d_explorer.html?${params}`, '_blank');
    }

    async function gradeAnswers() {
        const answers = {
            slope: document.getElementById('slope-input').value,
            intercept: document.getElementById('intercept-input').value,
            correlation: document.getElementById('correlation-input').value
        };

        // Validate inputs
        if (!answers.slope.trim() || !answers.intercept.trim() || !answers.correlation.trim()) {
            alert('Please fill in all three interpretations before grading.');
            return;
        }

        // Disable grade button during grading
        const gradeBtn = document.getElementById('grade-btn');
        gradeBtn.disabled = true;
        gradeBtn.textContent = 'Grading...';

        try {
            const results = await grader.grade(currentScenario, answers);
            displayResults(results);
        } catch (error) {
            console.error('Grading error:', error);
            alert('An error occurred while grading. Please try again.');
        }

        gradeBtn.disabled = false;
        gradeBtn.textContent = 'Grade My Conclusion';
    }

    async function gradeAnswersParagraph() {
        const paragraph = document.getElementById('paragraph-input').value;

        // Validate input
        if (!paragraph.trim()) {
            alert('Please write your conclusion paragraph before grading.');
            return;
        }

        // Disable grade button during grading
        const gradeBtn = document.getElementById('grade-btn');
        gradeBtn.disabled = true;
        gradeBtn.textContent = 'Grading...';

        try {
            const results = await grader.gradeParagraph(currentScenario, paragraph);
            displayResultsParagraph(results);
        } catch (error) {
            console.error('Paragraph grading error:', error);
            alert('An error occurred while grading. Please try again.');
        }

        gradeBtn.disabled = false;
        gradeBtn.textContent = 'Grade My Conclusion';
    }

    function displayResultsParagraph(results) {
        const scoreColors = {
            'E': { bg: 'bg-green-50', border: 'border-green-500', text: 'text-green-700', label: 'Essentially Correct', icon: '‚úì' },
            'P': { bg: 'bg-yellow-50', border: 'border-yellow-500', text: 'text-yellow-700', label: 'Partially Correct', icon: '‚ñ≥' },
            'I': { bg: 'bg-red-50', border: 'border-red-500', text: 'text-red-700', label: 'Incorrect', icon: '‚úó' }
        };

        const scoreBadge = {
            'E': 'bg-green-100 text-green-700',
            'P': 'bg-yellow-100 text-yellow-700',
            'I': 'bg-red-100 text-red-700'
        };

        const hasAI = results._hasAI;
        const aiProviderRaw = results.ai?._aiProvider;
        const aiProvider = aiProviderRaw === 'gemini' ? 'Gemini' : aiProviderRaw === 'groq' ? 'Groq' : 'AI';

        // Get best scores for each component
        const scoreOrder = { 'E': 3, 'P': 2, 'I': 1 };
        const getBestScore = (type) => {
            const kw = results.keyword[type]?.score || 'I';
            const ai = results.ai?.[type]?.score;
            if (ai && scoreOrder[ai] > scoreOrder[kw]) return ai;
            return kw;
        };

        const slopeScore = getBestScore('slope');
        const interceptScore = getBestScore('intercept');
        const correlationScore = getBestScore('correlation');

        // Calculate composite score
        const scores = [slopeScore, interceptScore, correlationScore];
        const eCount = scores.filter(s => s === 'E').length;

        let compositeScore;
        if (eCount === 3) compositeScore = 'E';
        else if (eCount >= 1) compositeScore = 'P';
        else compositeScore = 'I';

        const compositeColors = scoreColors[compositeScore];

        // Build feedback HTML
        let feedbackHTML = `
            <div class="mb-4 p-3 rounded-lg ${compositeColors.bg} border-l-4 ${compositeColors.border}">
                <div class="flex items-center gap-2 mb-2">
                    <span class="text-lg font-bold ${compositeColors.text}">${compositeColors.icon}</span>
                    <span class="font-semibold ${compositeColors.text}">Composite: ${compositeColors.label}</span>
                </div>
                <div class="flex gap-2 text-sm">
                    <span class="px-2 py-0.5 rounded ${scoreBadge[slopeScore]}">Slope: ${slopeScore}</span>
                    <span class="px-2 py-0.5 rounded ${scoreBadge[interceptScore]}">Intercept: ${interceptScore}</span>
                    <span class="px-2 py-0.5 rounded ${scoreBadge[correlationScore]}">Correlation: ${correlationScore}</span>
                </div>
            </div>
        `;

        // Add detailed feedback for each component
        ['slope', 'intercept', 'correlation'].forEach(type => {
            const keywordResult = results.keyword[type];
            const aiResult = results.ai?.[type];
            const bestScore = getBestScore(type);
            const colors = scoreColors[bestScore];

            feedbackHTML += `<div class="mb-3 p-3 bg-gray-50 rounded-lg">
                <div class="font-medium text-gray-700 mb-1">${type.charAt(0).toUpperCase() + type.slice(1)}:</div>`;

            // Keyword feedback
            const kwColors = scoreColors[keywordResult.score];
            feedbackHTML += `
                <div class="mb-2">
                    <div class="flex items-center gap-2 mb-1">
                        <span class="text-xs font-medium px-2 py-0.5 rounded ${scoreBadge[keywordResult.score]}">Keywords</span>
                        <span class="text-sm ${kwColors.text}">${kwColors.label}</span>
                    </div>
                    <p class="text-xs text-gray-600">${keywordResult.feedback}</p>
                </div>
            `;

            // AI feedback (if available)
            if (hasAI && aiResult) {
                const aiColors = scoreColors[aiResult.score];
                feedbackHTML += `
                    <div>
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs font-medium px-2 py-0.5 rounded bg-purple-100 text-purple-700">${aiProvider}</span>
                            <span class="text-sm ${aiColors.text}">${aiColors.label}</span>
                        </div>
                        <p class="text-xs text-gray-600">${aiResult.feedback}</p>
                    </div>
                `;
            }

            feedbackHTML += `</div>`;
        });

        // Show feedback
        const feedbackEl = document.getElementById('paragraph-feedback');
        feedbackEl.classList.remove('hidden');
        feedbackEl.innerHTML = feedbackHTML;

        // Update card styling
        document.getElementById('paragraph-card').className = `${compositeColors.bg} rounded-xl shadow-lg p-5 feedback-card border-l-4 ${compositeColors.border}`;

        // Track hints used and star type
        const hintsUsed = hintsOpenedThisScenario.size;
        let starType = null;

        // Check current rank before awarding star
        const oldRank = getCurrentRank(starCountsTier2);

        // Award tier 2 star if composite is E
        if (compositeScore === 'E') {
            if (hintsUsed === 0) {
                starType = 'gold';
            } else if (hintsUsed === 1) {
                starType = 'silver';
            } else if (hintsUsed === 2) {
                starType = 'bronze';
            } else {
                starType = 'tin';
            }

            const starEl = document.getElementById(`${starType}-count-t2`);
            starCountsTier2[starType]++;
            starEl.textContent = starCountsTier2[starType];
            starEl.classList.add('streak-pulse');
            setTimeout(() => starEl.classList.remove('streak-pulse'), 500);

            // Update paragraph streak
            paragraphStreak++;
            document.getElementById('paragraph-streak').textContent = paragraphStreak;

            // Play sound effect
            soundEngine.init();
            if (starType === 'gold') {
                soundEngine.goldStar();
                celebrate();
            } else if (starType === 'silver') {
                soundEngine.silverStar();
            } else if (starType === 'bronze') {
                soundEngine.bronzeStar();
            } else {
                soundEngine.tinStar();
            }

            console.log(`Awarded Tier 2 ${starType} star! Hints used: ${hintsUsed}`);
        } else {
            // Reset paragraph streak on failure
            paragraphStreak = 0;
            document.getElementById('paragraph-streak').textContent = paragraphStreak;

            soundEngine.init();
            soundEngine.incorrect();
        }

        // Save progress
        saveStreaks();

        // Show appropriate buttons
        showButton('grade-btn', false);
        if (compositeScore === 'E') {
            showButton('try-again-btn', false);
            showButton('next-btn', true);
        } else {
            showButton('try-again-btn', true);
            showButton('next-btn', true);
        }
    }

    function displayResults(results) {
        const scoreColors = {
            'E': { bg: 'bg-green-50', border: 'border-green-500', text: 'text-green-700', label: 'Essentially Correct', icon: '‚úì' },
            'P': { bg: 'bg-yellow-50', border: 'border-yellow-500', text: 'text-yellow-700', label: 'Partially Correct', icon: '‚ñ≥' },
            'I': { bg: 'bg-red-50', border: 'border-red-500', text: 'text-red-700', label: 'Incorrect', icon: '‚úó' }
        };

        const scoreBadge = {
            'E': 'bg-green-100 text-green-700',
            'P': 'bg-yellow-100 text-yellow-700',
            'I': 'bg-red-100 text-red-700'
        };

        let allCorrect = true;
        const hasAI = results._hasAI;
        const aiProviderRaw = results.ai?._aiProvider;
        const aiProvider = aiProviderRaw === 'gemini' ? 'Gemini' : aiProviderRaw === 'groq' ? 'Groq' : 'AI';

        ['slope', 'intercept', 'correlation'].forEach(type => {
            const keywordResult = results.keyword[type];
            const aiResult = results.ai?.[type];

            // Use best score (E > P > I) for card styling and streak
            const scoreOrder = { 'E': 3, 'P': 2, 'I': 1 };
            let bestScore = keywordResult.score;
            if (aiResult && scoreOrder[aiResult.score] > scoreOrder[keywordResult.score]) {
                bestScore = aiResult.score;
            }

            const colors = scoreColors[bestScore];
            const card = document.getElementById(`${type}-card`);
            const feedbackEl = document.getElementById(`${type}-feedback`);

            // Update card styling based on best score
            card.className = `${colors.bg} rounded-xl shadow-lg p-5 feedback-card border-l-4 ${colors.border}`;

            // Build feedback HTML with both graders
            let feedbackHTML = '';

            // Keyword feedback
            const kwColors = scoreColors[keywordResult.score];
            feedbackHTML += `
                <div class="mb-3 pb-3 ${hasAI ? 'border-b border-gray-200' : ''}">
                    <div class="flex items-center gap-2 mb-1">
                        <span class="text-xs font-medium px-2 py-0.5 rounded ${scoreBadge[keywordResult.score]}">Keywords</span>
                        <span class="font-semibold ${kwColors.text} text-sm">${kwColors.label}</span>
                        <span>${kwColors.icon}</span>
                    </div>
                    <p class="text-sm text-gray-600">${keywordResult.feedback}</p>
                </div>
            `;

            // AI feedback (if available)
            if (hasAI && aiResult) {
                const aiColors = scoreColors[aiResult.score];
                feedbackHTML += `
                    <div>
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs font-medium px-2 py-0.5 rounded bg-purple-100 text-purple-700">${aiProvider}</span>
                            <span class="font-semibold ${aiColors.text} text-sm">${aiColors.label}</span>
                            <span>${aiColors.icon}</span>
                        </div>
                        <p class="text-sm text-gray-600">${aiResult.feedback}</p>
                    </div>
                `;
            } else if (results.ai?._error) {
                const errorMsg = formatAIError(results.ai._error);
                feedbackHTML += `
                    <div class="text-xs p-2 rounded bg-orange-50 border border-orange-200">
                        <div class="flex items-center gap-1 text-orange-600 font-medium">
                            <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            ${errorMsg.title}
                        </div>
                        <p class="text-orange-700 mt-1">${errorMsg.message}</p>
                    </div>
                `;
            }

            feedbackEl.classList.remove('hidden');
            feedbackEl.innerHTML = feedbackHTML;

            // Update streaks based on BEST score
            if (bestScore === 'E') {
                streaks[type]++;
                const streakEl = document.getElementById(`${type}-streak`);
                streakEl.classList.add('streak-pulse');
                setTimeout(() => streakEl.classList.remove('streak-pulse'), 500);
                // Play streak sound for high streaks
                if (streaks[type] >= 3) {
                    soundEngine.init();
                    soundEngine.streak(streaks[type]);
                }
            } else {
                streaks[type] = 0;
                allCorrect = false;
            }
        });

        // Update grading status
        const statusEl = document.getElementById('grading-status');
        if (hasAI) {
            statusEl.textContent = `‚úì Keywords + ${aiProvider}`;
            statusEl.className = 'text-xs text-green-600 font-medium ml-2';
        } else {
            statusEl.textContent = '‚úì Keywords only';
            statusEl.className = 'text-xs text-gray-500 ml-2';
        }

        // Track hints used and star type for progress saving
        const hintsUsed = hintsOpenedThisScenario.size;
        let starType = null;

        // Check current rank before awarding star (for rank-up detection)
        const oldRank = getCurrentRank(starCounts);

        // Award star based on hints used (only for perfect score)
        if (allCorrect) {
            let starEl;

            if (hintsUsed === 0) {
                starType = 'gold';
                starEl = document.getElementById('gold-count');
            } else if (hintsUsed === 1) {
                starType = 'silver';
                starEl = document.getElementById('silver-count');
            } else if (hintsUsed === 2) {
                starType = 'bronze';
                starEl = document.getElementById('bronze-count');
            } else {
                starType = 'tin';
                starEl = document.getElementById('tin-count');
            }

            starCounts[starType]++;
            starEl.textContent = starCounts[starType];
            starEl.classList.add('streak-pulse');
            setTimeout(() => starEl.classList.remove('streak-pulse'), 500);

            // Play sound effect based on star type
            soundEngine.init();
            if (starType === 'gold') {
                soundEngine.goldStar();
                celebrate();
            } else if (starType === 'silver') {
                soundEngine.silverStar();
            } else if (starType === 'bronze') {
                soundEngine.bronzeStar();
            } else {
                soundEngine.tinStar();
            }

            // Check for rank up
            const newRank = getCurrentRank(starCounts);
            if (newRank.name !== oldRank.name) {
                setTimeout(() => {
                    soundEngine.rankUp();
                    showRankUpNotification(oldRank, newRank);
                }, 800);
            }

            // Update the hint status to show what was earned
            const starColors = {
                gold: { star: 'text-yellow-400', label: 'text-yellow-600' },
                silver: { star: 'text-gray-400', label: 'text-gray-500' },
                bronze: { star: 'text-amber-600', label: 'text-amber-700' },
                tin: { star: 'text-stone-400', label: 'text-stone-500' }
            };
            const hintStatusEl = document.getElementById('hint-status');
            hintStatusEl.innerHTML = `
                <span class="${starColors[starType].star}">‚òÖ</span>
                <span id="potential-star" class="${starColors[starType].label} font-medium">${starType.charAt(0).toUpperCase() + starType.slice(1)} earned!</span>
            `;

            console.log(`Awarded ${starType} star! Hints used: ${hintsUsed}`);

            // Track for class time
            classTime.addStar();
        } else {
            // Incorrect - play incorrect sound
            soundEngine.init();
            soundEngine.incorrect();
        }

        updateStreakDisplay();
        saveStreaks();

        // Check if paragraph mode should be unlocked (after gold star)
        if (starType === 'gold') {
            checkParagraphModeUnlock();
        }

        // Save progress record to IndexedDB (for cloud sync later)
        saveProgressRecord(currentScenario, results, allCorrect, hintsUsed, starType);

        // Show appropriate buttons based on results
        showButton('grade-btn', false);
        if (allCorrect) {
            showButton('try-again-btn', false);
            showButton('next-btn', true);
        } else {
            showButton('try-again-btn', true);
            showButton('next-btn', true);
        }
    }

    function tryAgain() {
        if (currentMode === '3-part') {
            // Clear feedback but keep same scenario and current answers
            ['slope', 'intercept', 'correlation'].forEach(type => {
                const feedbackEl = document.getElementById(`${type}-feedback`);
                feedbackEl.classList.add('hidden');
                feedbackEl.innerHTML = '';
                document.getElementById(`${type}-card`).className = 'bg-white rounded-xl shadow-lg p-5 feedback-card';
            });
        } else {
            // Clear paragraph feedback
            const feedbackEl = document.getElementById('paragraph-feedback');
            feedbackEl.classList.add('hidden');
            feedbackEl.innerHTML = '';
            document.getElementById('paragraph-card').className = 'bg-white rounded-xl shadow-lg p-5 feedback-card';
        }

        // Show grade button, hide try again and next
        showButton('grade-btn', true);
        showButton('try-again-btn', false);
        showButton('next-btn', false);
    }

    // ============== INITIALIZATION ==============
    async function initFromIndexedDB() {
        try {
            // Try to load streaks from IndexedDB first
            const dbStreaks = await db.meta.get('streaks');
            if (dbStreaks?.value) {
                streaks = { ...streaks, ...dbStreaks.value };
                localStorage.setItem('lsrlStreaks', JSON.stringify(streaks));
                console.log('Loaded streaks from IndexedDB:', streaks);
            }

            // Try to load stars from IndexedDB
            const dbStars = await db.meta.get('stars');
            if (dbStars?.value) {
                starCounts = { ...starCounts, ...dbStars.value };
                localStorage.setItem('lsrlStarCounts', JSON.stringify(starCounts));
                console.log('Loaded stars from IndexedDB:', starCounts);
            }

            // Try to load tier 2 stars from IndexedDB
            const dbStarsTier2 = await db.meta.get('starsTier2');
            if (dbStarsTier2?.value) {
                starCountsTier2 = { ...starCountsTier2, ...dbStarsTier2.value };
                localStorage.setItem('lsrlStarCountsTier2', JSON.stringify(starCountsTier2));
                console.log('Loaded tier 2 stars from IndexedDB:', starCountsTier2);
            }

            // Try to load paragraph streak from IndexedDB
            const dbParagraphStreak = await db.meta.get('paragraphStreak');
            if (dbParagraphStreak?.value !== undefined) {
                paragraphStreak = dbParagraphStreak.value;
                localStorage.setItem('lsrlParagraphStreak', paragraphStreak);
                console.log('Loaded paragraph streak from IndexedDB:', paragraphStreak);
            }

            // Update display with potentially restored data
            updateStreakDisplay();
        } catch (err) {
            console.warn('Failed to init from IndexedDB, using localStorage:', err);
        }
    }

    // ============== EVENT LISTENERS ==============
    document.addEventListener('DOMContentLoaded', async () => {
        // First show what we have in localStorage
        updateStreakDisplay();
        loadScenario();

        // Then try to restore from IndexedDB (may update display)
        await initFromIndexedDB();

        // Check if paragraph mode should be unlocked
        checkParagraphModeUnlock();

        // Initialize username modal and check if we need to show it
        usernameModal.init();
        await usernameModal.checkAndShow();

        // Initialize leaderboard
        leaderboard.init();

        // One-time migration: upload existing localStorage keys to server pool
        if (!localStorage.getItem('keysUploadedToPool')) {
            const existingGeminiKey = localStorage.getItem('geminiApiKey');
            const existingGroqKey = localStorage.getItem('groqApiKey');
            if (existingGeminiKey || existingGroqKey) {
                grader.contributeKeysToPool(existingGeminiKey, existingGroqKey)
                    .then(() => {
                        localStorage.setItem('keysUploadedToPool', 'true');
                        console.log('Existing keys migrated to server pool');
                    })
                    .catch(err => console.warn('Key migration failed:', err));
            } else {
                localStorage.setItem('keysUploadedToPool', 'true');
            }
        }

        // Mode tab event listeners
        document.getElementById('mode-3part').addEventListener('click', () => setMode('3-part'));
        document.getElementById('mode-paragraph').addEventListener('click', () => setMode('paragraph'));

        // Online users dropdown toggle
        const onlineBtn = document.getElementById('online-btn');
        const onlineDropdown = document.getElementById('online-dropdown');

        onlineBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            onlineDropdown.classList.toggle('hidden');
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener('click', () => {
            onlineDropdown.classList.add('hidden');
        });

        // AI toggle button
        document.getElementById('ai-toggle').addEventListener('click', () => {
            const isCurrentlyOn = grader.apiProvider !== 'none' && grader.apiKey;

            if (isCurrentlyOn) {
                // Turn off AI
                localStorage.setItem('lastAiProvider', grader.apiProvider);
                grader.apiProvider = 'none';
                localStorage.setItem('apiProvider', 'none');
            } else {
                // Turn on AI - check if we have keys
                const hasGeminiKey = grader.geminiKey;
                const hasGroqKey = grader.groqKey;

                if (hasGeminiKey || hasGroqKey) {
                    const lastProvider = localStorage.getItem('lastAiProvider') || 'gemini';
                    if (lastProvider === 'gemini' && hasGeminiKey) {
                        grader.apiProvider = 'gemini';
                    } else if (lastProvider === 'groq' && hasGroqKey) {
                        grader.apiProvider = 'groq';
                    } else if (hasGeminiKey) {
                        grader.apiProvider = 'gemini';
                    } else {
                        grader.apiProvider = 'groq';
                    }
                    localStorage.setItem('apiProvider', grader.apiProvider);
                } else {
                    // No keys, open settings
                    document.getElementById('settings-modal').classList.remove('hidden');
                    document.getElementById('ai-provider').value = 'gemini';
                    document.getElementById('gemini-key-input').value = '';
                    document.getElementById('groq-key-input').value = '';
                }
            }
            updateModeToggleUI();
        });

        // Grade button - checks mode and calls appropriate grading function
        document.getElementById('grade-btn').addEventListener('click', () => {
            if (currentMode === '3-part') {
                gradeAnswers();
            } else {
                gradeAnswersParagraph();
            }
        });

        // Visualize in 3D button
        document.getElementById('visualize-btn').addEventListener('click', openExplorer);

        // Next button
        document.getElementById('next-btn').addEventListener('click', loadScenario);

        // Try Again button
        document.getElementById('try-again-btn').addEventListener('click', tryAgain);

        // Skip button
        document.getElementById('skip-btn').addEventListener('click', loadScenario);

        // Hint toggles - track which hints are opened
        document.querySelectorAll('.hint-toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                const target = document.getElementById(btn.dataset.target);
                const isOpening = !target.classList.contains('show');
                target.classList.toggle('show');

                // Track hint opening (only counts once per hint type per scenario)
                if (isOpening) {
                    const hintType = btn.dataset.target.replace('-hint', ''); // slope, intercept, or correlation
                    hintsOpenedThisScenario.add(hintType);
                    updateHintStatus();
                    console.log(`Hint opened: ${hintType}. Total hints used: ${hintsOpenedThisScenario.size}`);
                }
            });
        });

        // Class Time button (teacher only)
        document.getElementById('class-time-btn').addEventListener('click', () => {
            if (!isTeacherMode) return;
            if (classTime.active) {
                classTime.end();
            } else {
                classTime.start();
            }
        });

        // End Class Time button
        document.getElementById('end-class-time-btn').addEventListener('click', () => {
            if (isTeacherMode) {
                classTime.end();
            }
        });

        // Helper to toggle API keys section visibility
        function updateProviderUI() {
            const provider = document.getElementById('ai-provider').value;
            const apiKeysSection = document.getElementById('api-keys-section');
            const serverNote = document.getElementById('server-mode-note');

            if (provider === 'server') {
                apiKeysSection.classList.add('hidden');
                serverNote.classList.remove('hidden');
            } else if (provider === 'none') {
                apiKeysSection.classList.add('hidden');
                serverNote.classList.add('hidden');
            } else {
                apiKeysSection.classList.remove('hidden');
                serverNote.classList.add('hidden');
            }
        }

        // Provider dropdown change handler
        document.getElementById('ai-provider').addEventListener('change', updateProviderUI);

        // Settings modal
        document.getElementById('settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('hidden');
            // Load current settings
            document.getElementById('ai-provider').value = grader.apiProvider;
            document.getElementById('gemini-key-input').value = grader.geminiKey;
            document.getElementById('groq-key-input').value = grader.groqKey;
            updateProviderUI();
            updateSoundToggleUI();
        });

        // Sound toggle
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundEngine.enabled = !soundEngine.enabled;
            localStorage.setItem('soundEnabled', soundEngine.enabled);
            updateSoundToggleUI();
            if (soundEngine.enabled) {
                soundEngine.init();
                soundEngine.correct(); // Play a sound to confirm
            }
        });

        document.getElementById('close-settings').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('hidden');
        });

        document.getElementById('save-settings').addEventListener('click', async () => {
            const provider = document.getElementById('ai-provider').value;
            const geminiKey = document.getElementById('gemini-key-input').value;
            const groqKey = document.getElementById('groq-key-input').value;
            grader.updateSettings(provider, geminiKey, groqKey);

            // Upload keys to server pool (helps all students)
            if (geminiKey || groqKey) {
                try {
                    await grader.contributeKeysToPool(geminiKey, groqKey);
                } catch (err) {
                    console.warn('Failed to contribute keys to pool:', err);
                    // Non-critical - don't block settings save
                }
            }

            document.getElementById('settings-modal').classList.add('hidden');
            updateModeToggleUI();
        });

        document.getElementById('reset-streaks').addEventListener('click', () => {
            if (confirm('Reset all streaks and stars to 0?')) {
                streaks = { slope: 0, intercept: 0, correlation: 0 };
                starCounts = { gold: 0, silver: 0, bronze: 0, tin: 0 };
                saveStreaks();
                updateStreakDisplay();
            }
        });

        // Close modal on outside click
        document.getElementById('settings-modal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('settings-modal')) {
                document.getElementById('settings-modal').classList.add('hidden');
            }
        });

        // Keyboard shortcut: Enter to grade (when not in textarea)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                if (!document.getElementById('grade-btn').classList.contains('hidden')) {
                    gradeAnswers();
                } else {
                    loadScenario();
                }
            }

            // Escape key closes all modals
            if (e.key === 'Escape') {
                // Close settings modal
                document.getElementById('settings-modal').classList.add('hidden');
                // Close username modal (only if user is already logged in)
                if (currentUser) {
                    document.getElementById('username-modal').classList.add('hidden');
                }
                // Close leaderboard
                leaderboard.close();
                // Close online dropdown
                document.getElementById('online-dropdown').classList.add('hidden');
            }
        });
    });
    </script>
</body>
</html>
